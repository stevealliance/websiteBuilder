#!/usr/bin/env node


// -*- coding: utf-8 -*-
'use strict';
/* !
    region header
    Copyright Torben Sickert (info["~at~"]torben.website) 16.12.2012

    License
    -------

    This library written by Torben Sickert stand under a creative commons naming
    3.0 unported license. see http://creativecommons.org/licenses/by/3.0/deed.de
    endregion
*/
// region imports

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _clientnode = require('clientnode');

var _clientnode2 = _interopRequireDefault(_clientnode);

var _jsdom = require('jsdom');

var _fs = require('fs');

var fileSystem = _interopRequireWildcard(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: Only needed for debugging this file.
try {
    require('source-map-support/register');
} catch (error) {}
// endregion
// region methods
/**
 * Provides a class of static methods with generic use cases.
 */
class Helper {
    // region boolean
    /**
     * Determines whether given file path is within given list of file
     * locations.
     * @param filePath - Path to file to check.
     * @param locationsToCheck - Locations to take into account.
     * @returns Value "true" if given file path is within one of given
     * locations or "false" otherwise.
     */
    static isFilePathInLocation(filePath, locationsToCheck) {
        for (const pathToCheck of locationsToCheck) if (_path2.default.resolve(filePath).startsWith(_path2.default.resolve(pathToCheck))) return true;
        return false;
    }
    // endregion
    // region string
    /**
     * In places each matching cascading style sheet or javaScript file
     * reference.
     * @param content - Markup content to process.
     * @param cascadingStyleSheetPattern - Pattern to match cascading style
     * sheet asset references again.
     * @param javaScriptPattern - Pattern to match javaScript asset references
     * again.
     * @param basePath - Base path to use as prefix for file references.
     * @param cascadingStyleSheetChunkNameTemplate - Cascading style sheet
     * chunk name template to use for asset matching.
     * @param javaScriptChunkNameTemplate - JavaScript chunk name template to
     * use for asset matching.
     * @param assets - Mapping of asset file paths to their content.
     * @returns Given an transformed markup.
     */
    static inPlaceCSSAndJavaScriptAssetReferences(content, cascadingStyleSheetPattern, javaScriptPattern, basePath, cascadingStyleSheetChunkNameTemplate, javaScriptChunkNameTemplate, assets) {
        /*
            NOTE: We have to translate template delimiter to html compatible
            sequences and translate it back later to avoid unexpected escape
            sequences in resulting html.
        */
        return new _promise2.default((resolve, reject) => {
            let window;
            try {
                window = new _jsdom.JSDOM(content.replace(/<%/g, '##+#+#+##').replace(/%>/g, '##-#-#-##')).window;
            } catch (error) {
                return reject(error);
            }
            const filePathsToRemove = [];
            if (cascadingStyleSheetPattern) for (const pattern in cascadingStyleSheetPattern) {
                if (!cascadingStyleSheetPattern.hasOwnProperty(pattern)) continue;
                let selector = '[href*=".css"]';
                if (pattern !== '*') selector = '[href="' + _path2.default.relative(basePath, Helper.renderFilePathTemplate(cascadingStyleSheetChunkNameTemplate, {
                    '[contenthash]': '',
                    '[id]': pattern,
                    '[name]': pattern
                })) + '"]';
                const domNodes = window.document.querySelectorAll(`link${selector}`);
                if (domNodes.length) for (const domNode of domNodes) {
                    const inPlaceDomNode = window.document.createElement('style');
                    const path = domNode.attributes.href.value.replace(/&.*/g, '');
                    if (!assets.hasOwnProperty(path)) continue;
                    inPlaceDomNode.textContent = assets[path].source();
                    if (cascadingStyleSheetPattern[pattern] === 'body') window.document.body.appendChild(inPlaceDomNode);else if (cascadingStyleSheetPattern[pattern] === 'in') domNode.parentNode.insertBefore(inPlaceDomNode, domNode);else if (cascadingStyleSheetPattern[pattern] === 'head') window.document.head.appendChild(inPlaceDomNode);
                    domNode.parentNode.removeChild(domNode);
                    /*
                        NOTE: This doesn't prevent webpack from
                        creating this file if present in another chunk
                        so removing it (and a potential source map
                        file) later in the "done" hook.
                    */
                    filePathsToRemove.push(Helper.stripLoader(path));
                    delete assets[path];
                } else console.warn('No referenced cascading style sheet file in ' + 'resulting markup found with selector: link' + selector);
            }
            if (javaScriptPattern) for (const pattern in javaScriptPattern) {
                if (!javaScriptPattern.hasOwnProperty(pattern)) continue;
                let selector = '[href*=".js"]';
                if (pattern !== '*') selector = '[src^="' + _path2.default.relative(basePath, Helper.renderFilePathTemplate(javaScriptChunkNameTemplate, {
                    '[hash]': '',
                    '[id]': pattern,
                    '[name]': pattern
                }) + '"]');
                const domNodes = window.document.querySelectorAll(`script${selector}`);
                if (domNodes.length) for (const domNode of domNodes) {
                    const inPlaceDomNode = window.document.createElement('script');
                    const path = domNode.attributes.src.value.replace(/&.*/g, '');
                    if (!assets.hasOwnProperty(path)) continue;
                    inPlaceDomNode.textContent = assets[path].source();
                    if (javaScriptPattern[pattern] === 'body') window.document.body.appendChild(inPlaceDomNode);else if (javaScriptPattern[pattern] === 'in') domNode.parentNode.insertBefore(inPlaceDomNode, domNode);else if (javaScriptPattern[pattern] === 'head') window.document.head.appendChild(inPlaceDomNode);
                    domNode.parentNode.removeChild(domNode);
                    /*
                        NOTE: This doesn't prevent webpack from
                        creating this file if present in another chunk
                        so removing it (and a potential source map
                        file) later in the "done" hook.
                    */
                    filePathsToRemove.push(Helper.stripLoader(path));
                    delete assets[path];
                } else console.warn('No referenced javaScript file in resulting ' + `markup found with selector: script${selector}`);
            }
            resolve({
                content: content.replace(/^(\s*<!doctype [^>]+?>\s*)[\s\S]*$/i, '$1') + window.document.documentElement.outerHTML.replace(/##\+#\+#\+##/g, '<%').replace(/##-#-#-##/g, '%>'),
                filePathsToRemove
            });
        });
    }
    /**
     * Strips loader informations form given module request including loader
     * prefix and query parameter.
     * @param moduleID - Module request to strip.
     * @returns Given module id stripped.
     */
    static stripLoader(moduleID) {
        moduleID = moduleID.toString();
        const moduleIDWithoutLoader = moduleID.substring(moduleID.lastIndexOf('!') + 1);
        return moduleIDWithoutLoader.includes('?') ? moduleIDWithoutLoader.substring(0, moduleIDWithoutLoader.indexOf('?')) : moduleIDWithoutLoader;
    }
    // endregion
    // region array
    /**
     * Converts given list of path to a normalized list with unique values.
     * @param paths - File paths.
     * @returns The given file path list with normalized unique values.
     */
    static normalizePaths(paths) {
        return (0, _from2.default)(new _set2.default(paths.map(givenPath => {
            givenPath = _path2.default.normalize(givenPath);
            if (givenPath.endsWith('/')) return givenPath.substring(0, givenPath.length - 1);
            return givenPath;
        })));
    }
    // endregion
    // region file handler
    /**
     * Applies file path/name placeholder replacements with given bundle
     * associated informations.
     * @param filePathTemplate - File path to process placeholder in.
     * @param informations - Scope to use for processing.
     * @returns Processed file path.
     */
    static renderFilePathTemplate(filePathTemplate, informations = {
        '[name]': '.__dummy__', '[id]': '.__dummy__',
        '[hash]': '.__dummy__'
    }) {
        let filePath = filePathTemplate;
        for (const placeholderName in informations) if (informations.hasOwnProperty(placeholderName)) filePath = filePath.replace(new RegExp(_clientnode2.default.stringEscapeRegularExpressions(placeholderName), 'g'), informations[placeholderName]);
        return filePath;
    }
    /**
     * Converts given request to a resolved request with given context
     * embedded.
     * @param request - Request to determine.
     * @param context - Context of given request to resolve relative to.
     * @param referencePath - Path to resolve local modules relative to.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of replacements to take into
     * account.
     * @param relativeModuleFilePaths - List of relative file path to search
     * for modules in.
     * @returns A new resolved request.
     */
    static applyContext(request, context = './', referencePath = './', aliases = {}, moduleReplacements = {}, relativeModuleFilePaths = ['node_modules']) {
        referencePath = _path2.default.resolve(referencePath);
        if (request.startsWith('./') && _path2.default.resolve(context) !== referencePath) {
            request = _path2.default.resolve(context, request);
            for (const modulePath of relativeModuleFilePaths) {
                const pathPrefix = _path2.default.resolve(referencePath, modulePath);
                if (request.startsWith(pathPrefix)) {
                    request = request.substring(pathPrefix.length);
                    if (request.startsWith('/')) request = request.substring(1);
                    return Helper.applyModuleReplacements(Helper.applyAliases(request.substring(request.lastIndexOf('!') + 1), aliases), moduleReplacements);
                }
            }
            if (request.startsWith(referencePath)) {
                request = request.substring(referencePath.length);
                if (request.startsWith('/')) request = request.substring(1);
                return Helper.applyModuleReplacements(Helper.applyAliases(request.substring(request.lastIndexOf('!') + 1), aliases), moduleReplacements);
            }
        }
        return request;
    }
    /**
     * Check if given request points to an external dependency not maintained
     * by current package context.
     * @param request - Request to determine.
     * @param context - Context of current project.
     * @param requestContext - Context of given request to resolve relative to.
     * @param normalizedInternalInjection - Mapping of chunk names to modules
     * which should be injected.
     * @param externalModuleLocations - Array if paths where external modules
     * take place.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of replacements to take into
     * account.
     * @param extensions - List of file and module extensions to take into
     * account.
     * @param referencePath - Path to resolve local modules relative to.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @param relativeModuleFilePaths - List of relative file path to search
     * for modules in.
     * @param packageEntryFileNames - List of package entry file names to
     * search for. The magic name "__package__" will search for an appreciate
     * entry in a "package.json" file.
     * @param packageMainPropertyNames - List of package file main property
     * names to search for package representing entry module definitions.
     * @param packageAliasPropertyNames - List of package file alias property
     * names to search for package specific module aliases.
     * @param includePattern - Array of regular expressions to explicitly mark
     * as external dependency.
     * @param excludePattern - Array of regular expressions to explicitly mark
     * as internal dependency.
     * @param inPlaceNormalLibrary - Indicates whether normal libraries should
     * be external or not.
     * @param inPlaceDynamicLibrary - Indicates whether requests with
     * integrated loader configurations should be marked as external or not.
     * @param encoding - Encoding for file names to use during file traversing.
     * @returns A new resolved request indicating whether given request is an
     * external one.
     */
    static determineExternalRequest(request, context = './', requestContext = './', normalizedInternalInjection = {}, externalModuleLocations = ['node_modules'], aliases = {}, moduleReplacements = {}, extensions = {
        file: {
            external: ['.js'],
            internal: ['.js', '.json', '.css', '.eot', '.gif', '.html', '.ico', '.jpg', '.png', '.ejs', '.svg', '.ttf', '.woff', '.woff2']
        }, module: []
    }, referencePath = './', pathsToIgnore = ['.git'], relativeModuleFilePaths = ['node_modules'], packageEntryFileNames = ['index', 'main'], packageMainPropertyNames = ['main', 'module'], packageAliasPropertyNames = [], includePattern = [], excludePattern = [], inPlaceNormalLibrary = false, inPlaceDynamicLibrary = true, encoding = 'utf-8') {
        context = _path2.default.resolve(context);
        requestContext = _path2.default.resolve(requestContext);
        referencePath = _path2.default.resolve(referencePath);
        // NOTE: We apply alias on externals additionally.
        let resolvedRequest = Helper.applyModuleReplacements(Helper.applyAliases(request.substring(request.lastIndexOf('!') + 1), aliases), moduleReplacements);
        /*
            NOTE: Aliases and module replacements doesn't have to be forwarded
            since we pass an already resolved request.
        */
        let filePath = Helper.determineModuleFilePath(resolvedRequest, {}, {}, extensions, context, requestContext, pathsToIgnore, relativeModuleFilePaths, packageEntryFileNames, packageMainPropertyNames, packageAliasPropertyNames, encoding);
        /*
            NOTE: We mark dependencies as external if there file couldn't be
            resolved or are specified to be external explicitly.
        */
        if (!(filePath || inPlaceNormalLibrary) || _clientnode2.default.isAnyMatching(resolvedRequest, includePattern)) return Helper.applyContext(resolvedRequest, requestContext, referencePath, aliases, moduleReplacements, relativeModuleFilePaths);
        if (_clientnode2.default.isAnyMatching(resolvedRequest, excludePattern)) return null;
        for (const chunkName in normalizedInternalInjection) if (normalizedInternalInjection.hasOwnProperty(chunkName)) for (const moduleID of normalizedInternalInjection[chunkName]) if (Helper.determineModuleFilePath(moduleID, aliases, moduleReplacements, extensions, context, requestContext, pathsToIgnore, relativeModuleFilePaths, packageEntryFileNames, packageMainPropertyNames, packageAliasPropertyNames, encoding) === filePath) return null;
        /*
            NOTE: We mark dependencies as external if they does not contain a
            loader in their request and aren't part of the current main package
            or have a file extension other than javaScript aware.
        */
        if (!inPlaceNormalLibrary && (extensions.file.external.length === 0 || filePath && extensions.file.external.includes(_path2.default.extname(filePath)) || !filePath && extensions.file.external.includes('')) && !(inPlaceDynamicLibrary && request.includes('!')) && (!filePath && inPlaceDynamicLibrary || filePath && (!filePath.startsWith(context) || Helper.isFilePathInLocation(filePath, externalModuleLocations)))) return Helper.applyContext(resolvedRequest, requestContext, referencePath, aliases, moduleReplacements, relativeModuleFilePaths);
        return null;
    }
    /**
     * Determines asset type of given file.
     * @param filePath - Path to file to analyse.
     * @param buildConfiguration - Meta informations for available asset
     * types.
     * @param paths - List of paths to search if given path doesn't reference
     * a file directly.
     * @returns Determined file type or "null" of given file couldn't be
     * determined.
     */
    static determineAssetType(filePath, buildConfiguration, paths) {
        let result = null;
        for (const type in buildConfiguration) if (_path2.default.extname(filePath) === `.${buildConfiguration[type].extension}`) {
            result = type;
            break;
        }
        if (!result) for (const type of ['source', 'target']) for (const assetType in paths[type].asset) if (paths[type].asset.hasOwnProperty(assetType) && assetType !== 'base' && paths[type].asset[assetType] && filePath.startsWith(paths[type].asset[assetType])) return assetType;
        return result;
    }
    /**
     * Adds a property with a stored array of all matching file paths, which
     * matches each build configuration in given entry path and converts given
     * build configuration into a sorted array were javaScript files takes
     * precedence.
     * @param configuration - Given build configurations.
     * @param entryPath - Path to analyse nested structure.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @param mainFileBasenames - File basenames to sort into the front.
     * @returns Converted build configuration.
     */
    static resolveBuildConfigurationFilePaths(configuration, entryPath = './', pathsToIgnore = ['.git'], mainFileBasenames = ['index', 'main']) {
        const buildConfiguration = [];
        for (const type in configuration) if (configuration.hasOwnProperty(type)) {
            const newItem = _clientnode2.default.extendObject(true, { filePaths: [] }, configuration[type]);
            for (const file of _clientnode2.default.walkDirectoryRecursivelySync(entryPath, file => {
                if (Helper.isFilePathInLocation(file.path, pathsToIgnore)) return false;
            })) if (file.stat.isFile() && _path2.default.extname(file.path).substring(1) === newItem.extension && !new RegExp(newItem.filePathPattern).test(file.path)) newItem.filePaths.push(file.path);
            newItem.filePaths.sort((firstFilePath, secondFilePath) => {
                if (mainFileBasenames.includes(_path2.default.basename(firstFilePath, _path2.default.extname(firstFilePath)))) {
                    if (mainFileBasenames.includes(_path2.default.basename(secondFilePath, _path2.default.extname(secondFilePath)))) return 0;
                } else if (mainFileBasenames.includes(_path2.default.basename(secondFilePath, _path2.default.extname(secondFilePath)))) return 1;
                return 0;
            });
            buildConfiguration.push(newItem);
        }
        return buildConfiguration.sort((first, second) => {
            if (first.outputExtension !== second.outputExtension) {
                if (first.outputExtension === 'js') return -1;
                if (second.outputExtension === 'js') return 1;
                return first.outputExtension < second.outputExtension ? -1 : 1;
            }
            return 0;
        });
    }
    /**
     * Determines all file and directory paths related to given internal
     * modules as array.
     * @param internalInjection - List of module ids or module file paths.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of module replacements to take into
     * account.
     * @param extensions - List of file and module extensions to take into
     * account.
     * @param context - File path to resolve relative to.
     * @param referencePath - Path to search for local modules.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @param relativeModuleFilePaths - List of relative file path to search
     * for modules in.
     * @param packageEntryFileNames - List of package entry file names to
     * search for. The magic name "__package__" will search for an appreciate
     * entry in a "package.json" file.
     * @param packageMainPropertyNames - List of package file main property
     * names to search for package representing entry module definitions.
     * @param packageAliasPropertyNames - List of package file alias property
     * names to search for package specific module aliases.
     * @param encoding - File name encoding to use during file traversing.
     * @returns Object with a file path and directory path key mapping to
     * corresponding list of paths.
     */
    static determineModuleLocations(internalInjection, aliases = {}, moduleReplacements = {}, extensions = {
        file: {
            external: ['.js'],
            internal: ['.js', '.json', '.css', '.eot', '.gif', '.html', '.ico', '.jpg', '.png', '.ejs', '.svg', '.ttf', '.woff', '.woff2']
        }, module: []
    }, context = './', referencePath = '', pathsToIgnore = ['.git'], relativeModuleFilePaths = ['', 'node_modules', '../'], packageEntryFileNames = ['__package__', '', 'index', 'main'], packageMainPropertyNames = ['main', 'module'], packageAliasPropertyNames = [], encoding = 'utf-8') {
        const filePaths = [];
        const directoryPaths = [];
        const normalizedInternalInjection = Helper.resolveModulesInFolders(Helper.normalizeInternalInjection(internalInjection), aliases, moduleReplacements, context, referencePath, pathsToIgnore);
        for (const chunkName in normalizedInternalInjection) if (normalizedInternalInjection.hasOwnProperty(chunkName)) for (const moduleID of normalizedInternalInjection[chunkName]) {
            const filePath = Helper.determineModuleFilePath(moduleID, aliases, moduleReplacements, extensions, context, referencePath, pathsToIgnore, relativeModuleFilePaths, packageEntryFileNames, packageMainPropertyNames, packageAliasPropertyNames, encoding);
            if (filePath) {
                filePaths.push(filePath);
                const directoryPath = _path2.default.dirname(filePath);
                if (!directoryPaths.includes(directoryPath)) directoryPaths.push(directoryPath);
            }
        }
        return { filePaths, directoryPaths };
    }
    /**
     * Determines a list of concrete file paths for given module id pointing to
     * a folder which isn't a package.
     * @param normalizedInternalInjection - Injection data structure of
     * modules with folder references to resolve.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of replacements to take into
     * account.
     * @param context - File path to determine relative to.
     * @param referencePath - Path to resolve local modules relative to.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @returns Given injections with resolved folder pointing modules.
     */
    static resolveModulesInFolders(normalizedInternalInjection, aliases = {}, moduleReplacements = {}, context = './', referencePath = '', pathsToIgnore = ['.git']) {
        if (referencePath.startsWith('/')) referencePath = _path2.default.relative(context, referencePath);
        for (const chunkName in normalizedInternalInjection) if (normalizedInternalInjection.hasOwnProperty(chunkName)) {
            let index = 0;
            for (let moduleID of normalizedInternalInjection[chunkName]) {
                moduleID = Helper.applyModuleReplacements(Helper.applyAliases(Helper.stripLoader(moduleID), aliases), moduleReplacements);
                const resolvedPath = _path2.default.resolve(referencePath, moduleID);
                if (_clientnode2.default.isDirectorySync(resolvedPath)) {
                    normalizedInternalInjection[chunkName].splice(index, 1);
                    for (const file of _clientnode2.default.walkDirectoryRecursivelySync(resolvedPath, file => {
                        if (Helper.isFilePathInLocation(file.path, pathsToIgnore)) return false;
                    })) if (file.stat.isFile()) normalizedInternalInjection[chunkName].push('./' + _path2.default.relative(referencePath, _path2.default.resolve(resolvedPath, file.path)));
                } else if (moduleID.startsWith('./') && !moduleID.startsWith('./' + _path2.default.relative(context, referencePath))) normalizedInternalInjection[chunkName][index] = `./${_path2.default.relative(context, resolvedPath)}`;
                index += 1;
            }
        }
        return normalizedInternalInjection;
    }
    /**
     * Every injection definition type can be represented as plain object
     * (mapping from chunk name to array of module ids). This method converts
     * each representation into the normalized plain object notation.
     * @param internalInjection - Given internal injection to normalize.
     * @returns Normalized representation of given internal injection.
     */
    static normalizeInternalInjection(internalInjection) {
        let result = {};
        if (internalInjection instanceof Object && _clientnode2.default.isPlainObject(internalInjection)) {
            let hasContent = false;
            const chunkNamesToDelete = [];
            for (const chunkName in internalInjection) if (internalInjection.hasOwnProperty(chunkName)) if (Array.isArray(internalInjection[chunkName])) {
                if (internalInjection[chunkName].length > 0) {
                    hasContent = true;
                    result[chunkName] = internalInjection[chunkName];
                } else chunkNamesToDelete.push(chunkName);
            } else {
                hasContent = true;
                result[chunkName] = [internalInjection[chunkName]];
            }
            if (hasContent) for (const chunkName of chunkNamesToDelete) delete result[chunkName];else result = { index: [] };
        } else if (typeof internalInjection === 'string') result = { index: [internalInjection] };else if (Array.isArray(internalInjection)) result = { index: internalInjection };
        return result;
    }
    /**
     * Determines all concrete file paths for given injection which are marked
     * with the "__auto__" indicator.
     * @param givenInjection - Given internal and external injection to take
     * into account.
     * @param buildConfigurations - Resolved build configuration.
     * @param modulesToExclude - A list of modules to exclude (specified by
     * path or id) or a mapping from chunk names to module ids.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of replacements to take into
     * account.
     * @param extensions - List of file and module extensions to take into
     * account.
     * @param context - File path to use as starting point.
     * @param referencePath - Reference path from where local files should be
     * resolved.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @returns Given injection with resolved marked indicators.
     */
    static resolveInjection(givenInjection, buildConfigurations, modulesToExclude, aliases = {}, moduleReplacements = {}, extensions = {
        file: {
            external: ['.js'],
            internal: ['.js', '.json', '.css', '.eot', '.gif', '.html', '.ico', '.jpg', '.png', '.ejs', '.svg', '.ttf', '.woff', '.woff2']
        }, module: []
    }, context = './', referencePath = '', pathsToIgnore = ['.git']) {
        const injection = _clientnode2.default.extendObject(true, {}, givenInjection);
        const moduleFilePathsToExclude = Helper.determineModuleLocations(modulesToExclude, aliases, moduleReplacements, extensions, context, referencePath, pathsToIgnore).filePaths;
        for (const type of ['internal', 'external'])
        /* eslint-disable curly */
        if (typeof injection[type] === 'object') {
            for (const chunkName in injection[type]) if (injection[type][chunkName] === '__auto__') {
                injection[type][chunkName] = [];
                const modules = Helper.getAutoChunk(buildConfigurations, moduleFilePathsToExclude, referencePath);
                for (const subChunkName in modules) if (modules.hasOwnProperty(subChunkName)) injection[type][chunkName].push(modules[subChunkName]);
                /*
                    Reverse array to let javaScript and main files be
                    the last ones to export them rather.
                */
                injection[type][chunkName].reverse();
            }
        } else if (injection[type] === '__auto__')
            /* eslint-enable curly */
            injection[type] = Helper.getAutoChunk(buildConfigurations, moduleFilePathsToExclude, context);
        return injection;
    }
    /**
     * Determines all module file paths.
     * @param buildConfigurations - Resolved build configuration.
     * @param moduleFilePathsToExclude - A list of modules file paths to
     * exclude (specified by path or id) or a mapping from chunk names to
     * module ids.
     * @param context - File path to use as starting point.
     * @returns All determined module file paths.
     */
    static getAutoChunk(buildConfigurations, moduleFilePathsToExclude, context) {
        const result = {};
        const injectedModuleIDs = {};
        for (const buildConfiguration of buildConfigurations) {
            if (!injectedModuleIDs[buildConfiguration.outputExtension]) injectedModuleIDs[buildConfiguration.outputExtension] = [];
            for (const moduleFilePath of buildConfiguration.filePaths) if (!moduleFilePathsToExclude.includes(moduleFilePath)) {
                const relativeModuleFilePath = './' + _path2.default.relative(context, moduleFilePath);
                const directoryPath = _path2.default.dirname(relativeModuleFilePath);
                const baseName = _path2.default.basename(relativeModuleFilePath, `.${buildConfiguration.extension}`);
                let moduleID = baseName;
                if (directoryPath !== '.') moduleID = _path2.default.join(directoryPath, baseName);
                /*
                    Ensure that each output type has only one source
                    representation.
                */
                if (!injectedModuleIDs[buildConfiguration.outputExtension].includes(moduleID)) {
                    /*
                        Ensure that same module ids and different output
                        types can be distinguished by their extension
                        (JavaScript-Modules remains without extension since
                        they will be handled first because the build
                        configurations are expected to be sorted in this
                        context).
                    */
                    if (result.hasOwnProperty(moduleID)) result[relativeModuleFilePath] = relativeModuleFilePath;else result[moduleID] = relativeModuleFilePath;
                    injectedModuleIDs[buildConfiguration.outputExtension].push(moduleID);
                }
            }
        }
        return result;
    }
    /**
     * Determines a concrete file path for given module id.
     * @param moduleID - Module id to determine.
     * @param aliases - Mapping of aliases to take into account.
     * @param moduleReplacements - Mapping of replacements to take into
     * account.
     * @param extensions - List of file and module extensions to take into
     * account.
     * @param context - File path to determine relative to.
     * @param referencePath - Path to resolve local modules relative to.
     * @param pathsToIgnore - Paths which marks location to ignore.
     * @param relativeModuleFilePaths - List of relative file path to search
     * for modules in.
     * @param packageEntryFileNames - List of package entry file names to
     * search for. The magic name "__package__" will search for an appreciate
     * entry in a "package.json" file.
     * @param packageMainPropertyNames - List of package file main property
     * names to search for package representing entry module definitions.
     * @param packageAliasPropertyNames - List of package file alias property
     * names to search for package specific module aliases.
     * @param encoding - Encoding to use for file names during file traversing.
     * @returns File path or given module id if determinations has failed or
     * wasn't necessary.
     */
    static determineModuleFilePath(moduleID, aliases = {}, moduleReplacements = {}, extensions = {
        file: {
            external: ['.js'],
            internal: ['.js', '.json', '.css', '.eot', '.gif', '.html', '.ico', '.jpg', '.png', '.ejs', '.svg', '.ttf', '.woff', '.woff2']
        }, module: []
    }, context = './', referencePath = '', pathsToIgnore = ['.git'], relativeModuleFilePaths = ['node_modules'], packageEntryFileNames = ['index'], packageMainPropertyNames = ['main'], packageAliasPropertyNames = [], encoding = 'utf-8') {
        moduleID = Helper.applyModuleReplacements(Helper.applyAliases(Helper.stripLoader(moduleID), aliases), moduleReplacements);
        if (!moduleID) return null;
        let moduleFilePath = moduleID;
        if (moduleFilePath.startsWith('./')) moduleFilePath = _path2.default.join(referencePath, moduleFilePath);
        for (const moduleLocation of [referencePath].concat(relativeModuleFilePaths.map(filePath => _path2.default.resolve(context, filePath)))) for (let fileName of ['', '__package__'].concat(packageEntryFileNames)) for (const moduleExtension of extensions.module.concat([''])) for (const fileExtension of [''].concat(extensions.file.internal)) {
            let currentModuleFilePath;
            if (moduleFilePath.startsWith('/')) currentModuleFilePath = _path2.default.resolve(moduleFilePath);else currentModuleFilePath = _path2.default.resolve(moduleLocation, moduleFilePath);
            let packageAliases = {};
            if (fileName === '__package__') {
                if (_clientnode2.default.isDirectorySync(currentModuleFilePath)) {
                    const pathToPackageJSON = _path2.default.resolve(currentModuleFilePath, 'package.json');
                    if (_clientnode2.default.isFileSync(pathToPackageJSON)) {
                        let localConfiguration = {};
                        try {
                            localConfiguration = JSON.parse(fileSystem.readFileSync(pathToPackageJSON, { encoding }));
                        } catch (error) {}
                        for (const propertyName of packageMainPropertyNames) if (localConfiguration.hasOwnProperty(propertyName) && typeof localConfiguration[propertyName] === 'string' && localConfiguration[propertyName]) {
                            fileName = localConfiguration[propertyName];
                            break;
                        }
                        for (const propertyName of packageAliasPropertyNames) if (localConfiguration.hasOwnProperty(propertyName) && typeof localConfiguration[propertyName] === 'object') {
                            packageAliases = localConfiguration[propertyName];
                            break;
                        }
                    }
                }
                if (fileName === '__package__') continue;
            }
            fileName = Helper.applyModuleReplacements(Helper.applyAliases(fileName, packageAliases), moduleReplacements);
            if (fileName) currentModuleFilePath = _path2.default.resolve(currentModuleFilePath, `${fileName}${moduleExtension}${fileExtension}`);else currentModuleFilePath += `${fileName}${moduleExtension}${fileExtension}`;
            if (Helper.isFilePathInLocation(currentModuleFilePath, pathsToIgnore)) continue;
            if (_clientnode2.default.isFileSync(currentModuleFilePath)) return currentModuleFilePath;
        }
        return null;
    }
    // endregion
    /**
     * Determines a concrete file path for given module id.
     * @param moduleID - Module id to determine.
     * @param aliases - Mapping of aliases to take into account.
     * @returns The alias applied given module id.
     */
    static applyAliases(moduleID, aliases) {
        for (const alias in aliases) if (alias.endsWith('$')) {
            if (moduleID === alias.substring(0, alias.length - 1)) moduleID = aliases[alias];
        } else moduleID = moduleID.replace(alias, aliases[alias]);
        return moduleID;
    }
    /**
     * Determines a concrete file path for given module id.
     * @param moduleID - Module id to determine.
     * @param replacements - Mapping of regular expressions to their
     * corresponding replacements.
     * @returns The replacement applied given module id.
     */
    static applyModuleReplacements(moduleID, replacements) {
        for (const replacement in replacements) if (replacements.hasOwnProperty(replacement)) moduleID = moduleID.replace(new RegExp(replacement), replacements[replacement]);
        return moduleID;
    }
}
exports.default = Helper; // endregion
// region vim modline
// vim: set tabstop=4 shiftwidth=4 expandtab:
// vim: foldmethod=marker foldmarker=region,endregion:
// endregion

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPLG9CQUFQLENBQ0EscUJBREEsRUFDdUIsYUFEdkIsQ0FBSixFQUdJO0FBQ0osZ0JBQUkscUJBQU0sVUFBTixDQUFpQixxQkFBakIsQ0FBSixFQUNJLE9BQU8scUJBQVA7QUFDUDtBQUNiLGVBQU8sSUFBUDtBQUNIO0FBQ0Q7QUFDQTs7Ozs7O0FBTUEsV0FBTyxZQUFQLENBQW9CLFFBQXBCLEVBQXFDLE9BQXJDLEVBQWlFO0FBQzdELGFBQUssTUFBTSxLQUFYLElBQTJCLE9BQTNCLEVBQ0ksSUFBSSxNQUFNLFFBQU4sQ0FBZSxHQUFmLENBQUosRUFBeUI7QUFDckIsZ0JBQUksYUFBYSxNQUFNLFNBQU4sQ0FBZ0IsQ0FBaEIsRUFBbUIsTUFBTSxNQUFOLEdBQWUsQ0FBbEMsQ0FBakIsRUFDSSxXQUFXLFFBQVEsS0FBUixDQUFYO0FBQ1AsU0FIRCxNQUlJLFdBQVcsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLFFBQVEsS0FBUixDQUF4QixDQUFYO0FBQ1IsZUFBTyxRQUFQO0FBQ0g7QUFDRDs7Ozs7OztBQU9BLFdBQU8sdUJBQVAsQ0FDSSxRQURKLEVBQ3FCLFlBRHJCLEVBRVM7QUFDTCxhQUFLLE1BQU0sV0FBWCxJQUFpQyxZQUFqQyxFQUNJLElBQUksYUFBYSxjQUFiLENBQTRCLFdBQTVCLENBQUosRUFDSSxXQUFXLFNBQVMsT0FBVCxDQUNQLElBQUksTUFBSixDQUFXLFdBQVgsQ0FETyxFQUNrQixhQUFhLFdBQWIsQ0FEbEIsQ0FBWDtBQUVSLGVBQU8sUUFBUDtBQUNIO0FBajlCdUI7a0JBQVAsTSxFQW05QnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaGVscGVyLmNvbXBpbGVkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBAZmxvd1xuLy8gLSotIGNvZGluZzogdXRmLTggLSotXG4ndXNlIHN0cmljdCdcbi8qICFcbiAgICByZWdpb24gaGVhZGVyXG4gICAgQ29weXJpZ2h0IFRvcmJlbiBTaWNrZXJ0IChpbmZvW1wifmF0flwiXXRvcmJlbi53ZWJzaXRlKSAxNi4xMi4yMDEyXG5cbiAgICBMaWNlbnNlXG4gICAgLS0tLS0tLVxuXG4gICAgVGhpcyBsaWJyYXJ5IHdyaXR0ZW4gYnkgVG9yYmVuIFNpY2tlcnQgc3RhbmQgdW5kZXIgYSBjcmVhdGl2ZSBjb21tb25zIG5hbWluZ1xuICAgIDMuMCB1bnBvcnRlZCBsaWNlbnNlLiBzZWUgaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnkvMy4wL2RlZWQuZGVcbiAgICBlbmRyZWdpb25cbiovXG4vLyByZWdpb24gaW1wb3J0c1xuaW1wb3J0IHR5cGUge0RvbU5vZGV9IGZyb20gJ2NsaWVudG5vZGUnXG5pbXBvcnQgVG9vbHMgZnJvbSAnY2xpZW50bm9kZSdcbmltcG9ydCB0eXBlIHtGaWxlLCBQbGFpbk9iamVjdCwgV2luZG93fSBmcm9tICdjbGllbnRub2RlJ1xuaW1wb3J0IHtKU0RPTSBhcyBET019IGZyb20gJ2pzZG9tJ1xuaW1wb3J0ICogYXMgZmlsZVN5c3RlbSBmcm9tICdmcydcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG4vLyBOT1RFOiBPbmx5IG5lZWRlZCBmb3IgZGVidWdnaW5nIHRoaXMgZmlsZS5cbnRyeSB7XG4gICAgcmVxdWlyZSgnc291cmNlLW1hcC1zdXBwb3J0L3JlZ2lzdGVyJylcbn0gY2F0Y2ggKGVycm9yKSB7fVxuXG5pbXBvcnQgdHlwZSB7XG4gICAgQnVpbGRDb25maWd1cmF0aW9uLFxuICAgIEV4dGVuc2lvbnMsXG4gICAgSW5qZWN0aW9uLFxuICAgIEludGVybmFsSW5qZWN0aW9uLFxuICAgIE5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbixcbiAgICBQYXRoLFxuICAgIFJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uLFxuICAgIFJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbVxufSBmcm9tICcuL3R5cGUnXG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiBtZXRob2RzXG4vKipcbiAqIFByb3ZpZGVzIGEgY2xhc3Mgb2Ygc3RhdGljIG1ldGhvZHMgd2l0aCBnZW5lcmljIHVzZSBjYXNlcy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVscGVyIHtcbiAgICAvLyByZWdpb24gYm9vbGVhblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBnaXZlbiBmaWxlIHBhdGggaXMgd2l0aGluIGdpdmVuIGxpc3Qgb2YgZmlsZVxuICAgICAqIGxvY2F0aW9ucy5cbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBQYXRoIHRvIGZpbGUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIGxvY2F0aW9uc1RvQ2hlY2sgLSBMb2NhdGlvbnMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHJldHVybnMgVmFsdWUgXCJ0cnVlXCIgaWYgZ2l2ZW4gZmlsZSBwYXRoIGlzIHdpdGhpbiBvbmUgb2YgZ2l2ZW5cbiAgICAgKiBsb2NhdGlvbnMgb3IgXCJmYWxzZVwiIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNGaWxlUGF0aEluTG9jYXRpb24oXG4gICAgICAgIGZpbGVQYXRoOnN0cmluZywgbG9jYXRpb25zVG9DaGVjazpBcnJheTxzdHJpbmc+XG4gICAgKTpib29sZWFuIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoVG9DaGVjazpzdHJpbmcgb2YgbG9jYXRpb25zVG9DaGVjaylcbiAgICAgICAgICAgIGlmIChwYXRoLnJlc29sdmUoZmlsZVBhdGgpLnN0YXJ0c1dpdGgocGF0aC5yZXNvbHZlKHBhdGhUb0NoZWNrKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGVuZHJlZ2lvblxuICAgIC8vIHJlZ2lvbiBzdHJpbmdcbiAgICAvKipcbiAgICAgKiBJbiBwbGFjZXMgZWFjaCBtYXRjaGluZyBjYXNjYWRpbmcgc3R5bGUgc2hlZXQgb3IgamF2YVNjcmlwdCBmaWxlXG4gICAgICogcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBjb250ZW50IC0gTWFya3VwIGNvbnRlbnQgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gY2FzY2FkaW5nU3R5bGVTaGVldFBhdHRlcm4gLSBQYXR0ZXJuIHRvIG1hdGNoIGNhc2NhZGluZyBzdHlsZVxuICAgICAqIHNoZWV0IGFzc2V0IHJlZmVyZW5jZXMgYWdhaW4uXG4gICAgICogQHBhcmFtIGphdmFTY3JpcHRQYXR0ZXJuIC0gUGF0dGVybiB0byBtYXRjaCBqYXZhU2NyaXB0IGFzc2V0IHJlZmVyZW5jZXNcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKiBAcGFyYW0gYmFzZVBhdGggLSBCYXNlIHBhdGggdG8gdXNlIGFzIHByZWZpeCBmb3IgZmlsZSByZWZlcmVuY2VzLlxuICAgICAqIEBwYXJhbSBjYXNjYWRpbmdTdHlsZVNoZWV0Q2h1bmtOYW1lVGVtcGxhdGUgLSBDYXNjYWRpbmcgc3R5bGUgc2hlZXRcbiAgICAgKiBjaHVuayBuYW1lIHRlbXBsYXRlIHRvIHVzZSBmb3IgYXNzZXQgbWF0Y2hpbmcuXG4gICAgICogQHBhcmFtIGphdmFTY3JpcHRDaHVua05hbWVUZW1wbGF0ZSAtIEphdmFTY3JpcHQgY2h1bmsgbmFtZSB0ZW1wbGF0ZSB0b1xuICAgICAqIHVzZSBmb3IgYXNzZXQgbWF0Y2hpbmcuXG4gICAgICogQHBhcmFtIGFzc2V0cyAtIE1hcHBpbmcgb2YgYXNzZXQgZmlsZSBwYXRocyB0byB0aGVpciBjb250ZW50LlxuICAgICAqIEByZXR1cm5zIEdpdmVuIGFuIHRyYW5zZm9ybWVkIG1hcmt1cC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5QbGFjZUNTU0FuZEphdmFTY3JpcHRBc3NldFJlZmVyZW5jZXMoXG4gICAgICAgIGNvbnRlbnQ6c3RyaW5nLFxuICAgICAgICBjYXNjYWRpbmdTdHlsZVNoZWV0UGF0dGVybjo/e1trZXk6c3RyaW5nXTonYm9keSd8J2hlYWQnfCdpbid9LFxuICAgICAgICBqYXZhU2NyaXB0UGF0dGVybjo/e1trZXk6c3RyaW5nXTonYm9keSd8J2hlYWQnfCdpbid9LCBiYXNlUGF0aDpzdHJpbmcsXG4gICAgICAgIGNhc2NhZGluZ1N0eWxlU2hlZXRDaHVua05hbWVUZW1wbGF0ZTpzdHJpbmcsXG4gICAgICAgIGphdmFTY3JpcHRDaHVua05hbWVUZW1wbGF0ZTpzdHJpbmcsIGFzc2V0czp7W2tleTpzdHJpbmddOk9iamVjdH1cbiAgICApOlByb21pc2U8e2NvbnRlbnQ6c3RyaW5nO2ZpbGVQYXRoc1RvUmVtb3ZlOkFycmF5PHN0cmluZz47fT4ge1xuICAgICAgICAvKlxuICAgICAgICAgICAgTk9URTogV2UgaGF2ZSB0byB0cmFuc2xhdGUgdGVtcGxhdGUgZGVsaW1pdGVyIHRvIGh0bWwgY29tcGF0aWJsZVxuICAgICAgICAgICAgc2VxdWVuY2VzIGFuZCB0cmFuc2xhdGUgaXQgYmFjayBsYXRlciB0byBhdm9pZCB1bmV4cGVjdGVkIGVzY2FwZVxuICAgICAgICAgICAgc2VxdWVuY2VzIGluIHJlc3VsdGluZyBodG1sLlxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKFxuICAgICAgICAgICAgcmVzb2x2ZTpGdW5jdGlvbiwgcmVqZWN0OkZ1bmN0aW9uXG4gICAgICAgICk6dm9pZCA9PiB7XG4gICAgICAgICAgICBsZXQgd2luZG93OldpbmRvd1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cgPSAobmV3IERPTShjb250ZW50LnJlcGxhY2UoLzwlL2csICcjIysjKyMrIyMnKS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvJT4vZywgJyMjLSMtIy0jIydcbiAgICAgICAgICAgICAgICApKSkud2luZG93XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWxlUGF0aHNUb1JlbW92ZTpBcnJheTxzdHJpbmc+ID0gW11cbiAgICAgICAgICAgIGlmIChjYXNjYWRpbmdTdHlsZVNoZWV0UGF0dGVybilcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm46c3RyaW5nIGluIGNhc2NhZGluZ1N0eWxlU2hlZXRQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FzY2FkaW5nU3R5bGVTaGVldFBhdHRlcm4uaGFzT3duUHJvcGVydHkocGF0dGVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0b3I6c3RyaW5nID0gJ1tocmVmKj1cIi5jc3NcIl0nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuICE9PSAnKicpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICdbaHJlZj1cIicgKyBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoLCBIZWxwZXIucmVuZGVyRmlsZVBhdGhUZW1wbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzY2FkaW5nU3R5bGVTaGVldENodW5rTmFtZVRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW2NvbnRlbnRoYXNoXSc6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1tpZF0nOiBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1tuYW1lXSc6IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpICsgJ1wiXSdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZXM6QXJyYXk8RG9tTm9kZT4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYGxpbmske3NlbGVjdG9yfWApXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvbU5vZGU6RG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluUGxhY2VEb21Ob2RlOkRvbU5vZGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGg6c3RyaW5nID0gZG9tTm9kZS5hdHRyaWJ1dGVzLmhyZWYudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyYuKi9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFzc2V0cy5oYXNPd25Qcm9wZXJ0eShwYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBsYWNlRG9tTm9kZS50ZXh0Q29udGVudCA9IGFzc2V0c1twYXRoXS5zb3VyY2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXNjYWRpbmdTdHlsZVNoZWV0UGF0dGVybltwYXR0ZXJuXSA9PT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUGxhY2VEb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhc2NhZGluZ1N0eWxlU2hlZXRQYXR0ZXJuW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSA9PT0gJ2luJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUGxhY2VEb21Ob2RlLCBkb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhc2NhZGluZ1N0eWxlU2hlZXRQYXR0ZXJuW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSA9PT0gJ2hlYWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUGxhY2VEb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5PVEU6IFRoaXMgZG9lc24ndCBwcmV2ZW50IHdlYnBhY2sgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGluZyB0aGlzIGZpbGUgaWYgcHJlc2VudCBpbiBhbm90aGVyIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHJlbW92aW5nIGl0IChhbmQgYSBwb3RlbnRpYWwgc291cmNlIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlKSBsYXRlciBpbiB0aGUgXCJkb25lXCIgaG9vay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVQYXRoc1RvUmVtb3ZlLnB1c2goSGVscGVyLnN0cmlwTG9hZGVyKHBhdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhc3NldHNbcGF0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdObyByZWZlcmVuY2VkIGNhc2NhZGluZyBzdHlsZSBzaGVldCBmaWxlIGluICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZXN1bHRpbmcgbWFya3VwIGZvdW5kIHdpdGggc2VsZWN0b3I6IGxpbmsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoamF2YVNjcmlwdFBhdHRlcm4pXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuOnN0cmluZyBpbiBqYXZhU2NyaXB0UGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWphdmFTY3JpcHRQYXR0ZXJuLmhhc093blByb3BlcnR5KHBhdHRlcm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdG9yOnN0cmluZyA9ICdbaHJlZio9XCIuanNcIl0nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuICE9PSAnKicpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICdbc3JjXj1cIicgKyBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VQYXRoLCBIZWxwZXIucmVuZGVyRmlsZVBhdGhUZW1wbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgamF2YVNjcmlwdENodW5rTmFtZVRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW2hhc2hdJzogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW2lkXSc6IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW25hbWVdJzogcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArICdcIl0nKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlczpBcnJheTxEb21Ob2RlPiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgc2NyaXB0JHtzZWxlY3Rvcn1gKVxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBkb21Ob2RlOkRvbU5vZGUgb2YgZG9tTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpblBsYWNlRG9tTm9kZTpEb21Ob2RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aDpzdHJpbmcgPSBkb21Ob2RlLmF0dHJpYnV0ZXMuc3JjLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8mLiovZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3NldHMuaGFzT3duUHJvcGVydHkocGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5QbGFjZURvbU5vZGUudGV4dENvbnRlbnQgPSBhc3NldHNbcGF0aF0uc291cmNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoamF2YVNjcmlwdFBhdHRlcm5bcGF0dGVybl0gPT09ICdib2R5JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBsYWNlRG9tTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqYXZhU2NyaXB0UGF0dGVybltwYXR0ZXJuXSA9PT0gJ2luJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUGxhY2VEb21Ob2RlLCBkb21Ob2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGphdmFTY3JpcHRQYXR0ZXJuW3BhdHRlcm5dID09PSAnaGVhZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5QbGFjZURvbU5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbU5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9URTogVGhpcyBkb2Vzbid0IHByZXZlbnQgd2VicGFjayBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nIHRoaXMgZmlsZSBpZiBwcmVzZW50IGluIGFub3RoZXIgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc28gcmVtb3ZpbmcgaXQgKGFuZCBhIHBvdGVudGlhbCBzb3VyY2UgbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUpIGxhdGVyIGluIHRoZSBcImRvbmVcIiBob29rLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGhzVG9SZW1vdmUucHVzaChIZWxwZXIuc3RyaXBMb2FkZXIocGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFzc2V0c1twYXRoXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHJlZmVyZW5jZWQgamF2YVNjcmlwdCBmaWxlIGluIHJlc3VsdGluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgbWFya3VwIGZvdW5kIHdpdGggc2VsZWN0b3I6IHNjcmlwdCR7c2VsZWN0b3J9YClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9eKFxccyo8IWRvY3R5cGUgW14+XSs/PlxccyopW1xcc1xcU10qJC9pLCAnJDEnXG4gICAgICAgICAgICAgICAgKSArIHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC8jI1xcKyNcXCsjXFwrIyMvZywgJzwlJ1xuICAgICAgICAgICAgICAgICkucmVwbGFjZSgvIyMtIy0jLSMjL2csICclPicpLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoc1RvUmVtb3ZlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJpcHMgbG9hZGVyIGluZm9ybWF0aW9ucyBmb3JtIGdpdmVuIG1vZHVsZSByZXF1ZXN0IGluY2x1ZGluZyBsb2FkZXJcbiAgICAgKiBwcmVmaXggYW5kIHF1ZXJ5IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0gbW9kdWxlSUQgLSBNb2R1bGUgcmVxdWVzdCB0byBzdHJpcC5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBtb2R1bGUgaWQgc3RyaXBwZWQuXG4gICAgICovXG4gICAgc3RhdGljIHN0cmlwTG9hZGVyKG1vZHVsZUlEOnN0cmluZ3xTdHJpbmcpOnN0cmluZyB7XG4gICAgICAgIG1vZHVsZUlEID0gbW9kdWxlSUQudG9TdHJpbmcoKVxuICAgICAgICBjb25zdCBtb2R1bGVJRFdpdGhvdXRMb2FkZXI6c3RyaW5nID0gbW9kdWxlSUQuc3Vic3RyaW5nKFxuICAgICAgICAgICAgbW9kdWxlSUQubGFzdEluZGV4T2YoJyEnKSArIDEpXG4gICAgICAgIHJldHVybiBtb2R1bGVJRFdpdGhvdXRMb2FkZXIuaW5jbHVkZXMoXG4gICAgICAgICAgICAnPydcbiAgICAgICAgKSA/IG1vZHVsZUlEV2l0aG91dExvYWRlci5zdWJzdHJpbmcoMCwgbW9kdWxlSURXaXRob3V0TG9hZGVyLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgJz8nXG4gICAgICAgICAgICApKSA6IG1vZHVsZUlEV2l0aG91dExvYWRlclxuICAgIH1cbiAgICAvLyBlbmRyZWdpb25cbiAgICAvLyByZWdpb24gYXJyYXlcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBnaXZlbiBsaXN0IG9mIHBhdGggdG8gYSBub3JtYWxpemVkIGxpc3Qgd2l0aCB1bmlxdWUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBwYXRocyAtIEZpbGUgcGF0aHMuXG4gICAgICogQHJldHVybnMgVGhlIGdpdmVuIGZpbGUgcGF0aCBsaXN0IHdpdGggbm9ybWFsaXplZCB1bmlxdWUgdmFsdWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVQYXRocyhwYXRoczpBcnJheTxzdHJpbmc+KTpBcnJheTxzdHJpbmc+IHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChwYXRocy5tYXAoKGdpdmVuUGF0aDpzdHJpbmcpOnN0cmluZyA9PiB7XG4gICAgICAgICAgICBnaXZlblBhdGggPSBwYXRoLm5vcm1hbGl6ZShnaXZlblBhdGgpXG4gICAgICAgICAgICBpZiAoZ2l2ZW5QYXRoLmVuZHNXaXRoKCcvJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdpdmVuUGF0aC5zdWJzdHJpbmcoMCwgZ2l2ZW5QYXRoLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICByZXR1cm4gZ2l2ZW5QYXRoXG4gICAgICAgIH0pKSlcbiAgICB9XG4gICAgLy8gZW5kcmVnaW9uXG4gICAgLy8gcmVnaW9uIGZpbGUgaGFuZGxlclxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZmlsZSBwYXRoL25hbWUgcGxhY2Vob2xkZXIgcmVwbGFjZW1lbnRzIHdpdGggZ2l2ZW4gYnVuZGxlXG4gICAgICogYXNzb2NpYXRlZCBpbmZvcm1hdGlvbnMuXG4gICAgICogQHBhcmFtIGZpbGVQYXRoVGVtcGxhdGUgLSBGaWxlIHBhdGggdG8gcHJvY2VzcyBwbGFjZWhvbGRlciBpbi5cbiAgICAgKiBAcGFyYW0gaW5mb3JtYXRpb25zIC0gU2NvcGUgdG8gdXNlIGZvciBwcm9jZXNzaW5nLlxuICAgICAqIEByZXR1cm5zIFByb2Nlc3NlZCBmaWxlIHBhdGguXG4gICAgICovXG4gICAgc3RhdGljIHJlbmRlckZpbGVQYXRoVGVtcGxhdGUoXG4gICAgICAgIGZpbGVQYXRoVGVtcGxhdGU6c3RyaW5nLCBpbmZvcm1hdGlvbnM6e1trZXk6c3RyaW5nXTpzdHJpbmd9ID0ge1xuICAgICAgICAgICAgJ1tuYW1lXSc6ICcuX19kdW1teV9fJywgJ1tpZF0nOiAnLl9fZHVtbXlfXycsXG4gICAgICAgICAgICAnW2hhc2hdJzogJy5fX2R1bW15X18nXG4gICAgICAgIH1cbiAgICApOnN0cmluZyB7XG4gICAgICAgIGxldCBmaWxlUGF0aDpzdHJpbmcgPSBmaWxlUGF0aFRlbXBsYXRlXG4gICAgICAgIGZvciAoY29uc3QgcGxhY2Vob2xkZXJOYW1lOnN0cmluZyBpbiBpbmZvcm1hdGlvbnMpXG4gICAgICAgICAgICBpZiAoaW5mb3JtYXRpb25zLmhhc093blByb3BlcnR5KHBsYWNlaG9sZGVyTmFtZSkpXG4gICAgICAgICAgICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgIFRvb2xzLnN0cmluZ0VzY2FwZVJlZ3VsYXJFeHByZXNzaW9ucyhwbGFjZWhvbGRlck5hbWUpLCAnZydcbiAgICAgICAgICAgICAgICApLCBpbmZvcm1hdGlvbnNbcGxhY2Vob2xkZXJOYW1lXSlcbiAgICAgICAgcmV0dXJuIGZpbGVQYXRoXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGdpdmVuIHJlcXVlc3QgdG8gYSByZXNvbHZlZCByZXF1ZXN0IHdpdGggZ2l2ZW4gY29udGV4dFxuICAgICAqIGVtYmVkZGVkLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCB0byBkZXRlcm1pbmUuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9mIGdpdmVuIHJlcXVlc3QgdG8gcmVzb2x2ZSByZWxhdGl2ZSB0by5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlUGF0aCAtIFBhdGggdG8gcmVzb2x2ZSBsb2NhbCBtb2R1bGVzIHJlbGF0aXZlIHRvLlxuICAgICAqIEBwYXJhbSBhbGlhc2VzIC0gTWFwcGluZyBvZiBhbGlhc2VzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBtb2R1bGVSZXBsYWNlbWVudHMgLSBNYXBwaW5nIG9mIHJlcGxhY2VtZW50cyB0byB0YWtlIGludG9cbiAgICAgKiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocyAtIExpc3Qgb2YgcmVsYXRpdmUgZmlsZSBwYXRoIHRvIHNlYXJjaFxuICAgICAqIGZvciBtb2R1bGVzIGluLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHJlc29sdmVkIHJlcXVlc3QuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5Q29udGV4dChcbiAgICAgICAgcmVxdWVzdDpzdHJpbmcsIGNvbnRleHQ6c3RyaW5nID0gJy4vJywgcmVmZXJlbmNlUGF0aDpzdHJpbmcgPSAnLi8nLFxuICAgICAgICBhbGlhc2VzOlBsYWluT2JqZWN0ID0ge30sIG1vZHVsZVJlcGxhY2VtZW50czpQbGFpbk9iamVjdCA9IHt9LFxuICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRoczpBcnJheTxzdHJpbmc+ID0gWydub2RlX21vZHVsZXMnXVxuICAgICk6c3RyaW5nIHtcbiAgICAgICAgcmVmZXJlbmNlUGF0aCA9IHBhdGgucmVzb2x2ZShyZWZlcmVuY2VQYXRoKVxuICAgICAgICBpZiAocmVxdWVzdC5zdGFydHNXaXRoKCcuLycpICYmIHBhdGgucmVzb2x2ZShcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKSAhPT0gcmVmZXJlbmNlUGF0aCkge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHBhdGgucmVzb2x2ZShjb250ZXh0LCByZXF1ZXN0KVxuICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGVQYXRoOnN0cmluZyBvZiByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhQcmVmaXg6c3RyaW5nID0gcGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VQYXRoLCBtb2R1bGVQYXRoKVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXJ0c1dpdGgocGF0aFByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3Quc3Vic3RyaW5nKHBhdGhQcmVmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5zdGFydHNXaXRoKCcvJykpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdC5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlci5hcHBseU1vZHVsZVJlcGxhY2VtZW50cyhIZWxwZXIuYXBwbHlBbGlhc2VzKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zdWJzdHJpbmcocmVxdWVzdC5sYXN0SW5kZXhPZignIScpICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzXG4gICAgICAgICAgICAgICAgICAgICksIG1vZHVsZVJlcGxhY2VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGFydHNXaXRoKHJlZmVyZW5jZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3Quc3Vic3RyaW5nKHJlZmVyZW5jZVBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXJ0c1dpdGgoJy8nKSlcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3Quc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEhlbHBlci5hcHBseU1vZHVsZVJlcGxhY2VtZW50cyhIZWxwZXIuYXBwbHlBbGlhc2VzKFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnN1YnN0cmluZyhyZXF1ZXN0Lmxhc3RJbmRleE9mKCchJykgKyAxKSwgYWxpYXNlc1xuICAgICAgICAgICAgICAgICksIG1vZHVsZVJlcGxhY2VtZW50cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBnaXZlbiByZXF1ZXN0IHBvaW50cyB0byBhbiBleHRlcm5hbCBkZXBlbmRlbmN5IG5vdCBtYWludGFpbmVkXG4gICAgICogYnkgY3VycmVudCBwYWNrYWdlIGNvbnRleHQuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBSZXF1ZXN0IHRvIGRldGVybWluZS5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2YgY3VycmVudCBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0Q29udGV4dCAtIENvbnRleHQgb2YgZ2l2ZW4gcmVxdWVzdCB0byByZXNvbHZlIHJlbGF0aXZlIHRvLlxuICAgICAqIEBwYXJhbSBub3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24gLSBNYXBwaW5nIG9mIGNodW5rIG5hbWVzIHRvIG1vZHVsZXNcbiAgICAgKiB3aGljaCBzaG91bGQgYmUgaW5qZWN0ZWQuXG4gICAgICogQHBhcmFtIGV4dGVybmFsTW9kdWxlTG9jYXRpb25zIC0gQXJyYXkgaWYgcGF0aHMgd2hlcmUgZXh0ZXJuYWwgbW9kdWxlc1xuICAgICAqIHRha2UgcGxhY2UuXG4gICAgICogQHBhcmFtIGFsaWFzZXMgLSBNYXBwaW5nIG9mIGFsaWFzZXMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIG1vZHVsZVJlcGxhY2VtZW50cyAtIE1hcHBpbmcgb2YgcmVwbGFjZW1lbnRzIHRvIHRha2UgaW50b1xuICAgICAqIGFjY291bnQuXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBMaXN0IG9mIGZpbGUgYW5kIG1vZHVsZSBleHRlbnNpb25zIHRvIHRha2UgaW50b1xuICAgICAqIGFjY291bnQuXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZVBhdGggLSBQYXRoIHRvIHJlc29sdmUgbG9jYWwgbW9kdWxlcyByZWxhdGl2ZSB0by5cbiAgICAgKiBAcGFyYW0gcGF0aHNUb0lnbm9yZSAtIFBhdGhzIHdoaWNoIG1hcmtzIGxvY2F0aW9uIHRvIGlnbm9yZS5cbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHMgLSBMaXN0IG9mIHJlbGF0aXZlIGZpbGUgcGF0aCB0byBzZWFyY2hcbiAgICAgKiBmb3IgbW9kdWxlcyBpbi5cbiAgICAgKiBAcGFyYW0gcGFja2FnZUVudHJ5RmlsZU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGVudHJ5IGZpbGUgbmFtZXMgdG9cbiAgICAgKiBzZWFyY2ggZm9yLiBUaGUgbWFnaWMgbmFtZSBcIl9fcGFja2FnZV9fXCIgd2lsbCBzZWFyY2ggZm9yIGFuIGFwcHJlY2lhdGVcbiAgICAgKiBlbnRyeSBpbiBhIFwicGFja2FnZS5qc29uXCIgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGZpbGUgbWFpbiBwcm9wZXJ0eVxuICAgICAqIG5hbWVzIHRvIHNlYXJjaCBmb3IgcGFja2FnZSByZXByZXNlbnRpbmcgZW50cnkgbW9kdWxlIGRlZmluaXRpb25zLlxuICAgICAqIEBwYXJhbSBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGZpbGUgYWxpYXMgcHJvcGVydHlcbiAgICAgKiBuYW1lcyB0byBzZWFyY2ggZm9yIHBhY2thZ2Ugc3BlY2lmaWMgbW9kdWxlIGFsaWFzZXMuXG4gICAgICogQHBhcmFtIGluY2x1ZGVQYXR0ZXJuIC0gQXJyYXkgb2YgcmVndWxhciBleHByZXNzaW9ucyB0byBleHBsaWNpdGx5IG1hcmtcbiAgICAgKiBhcyBleHRlcm5hbCBkZXBlbmRlbmN5LlxuICAgICAqIEBwYXJhbSBleGNsdWRlUGF0dGVybiAtIEFycmF5IG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gZXhwbGljaXRseSBtYXJrXG4gICAgICogYXMgaW50ZXJuYWwgZGVwZW5kZW5jeS5cbiAgICAgKiBAcGFyYW0gaW5QbGFjZU5vcm1hbExpYnJhcnkgLSBJbmRpY2F0ZXMgd2hldGhlciBub3JtYWwgbGlicmFyaWVzIHNob3VsZFxuICAgICAqIGJlIGV4dGVybmFsIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0gaW5QbGFjZUR5bmFtaWNMaWJyYXJ5IC0gSW5kaWNhdGVzIHdoZXRoZXIgcmVxdWVzdHMgd2l0aFxuICAgICAqIGludGVncmF0ZWQgbG9hZGVyIGNvbmZpZ3VyYXRpb25zIHNob3VsZCBiZSBtYXJrZWQgYXMgZXh0ZXJuYWwgb3Igbm90LlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIGZvciBmaWxlIG5hbWVzIHRvIHVzZSBkdXJpbmcgZmlsZSB0cmF2ZXJzaW5nLlxuICAgICAqIEByZXR1cm5zIEEgbmV3IHJlc29sdmVkIHJlcXVlc3QgaW5kaWNhdGluZyB3aGV0aGVyIGdpdmVuIHJlcXVlc3QgaXMgYW5cbiAgICAgKiBleHRlcm5hbCBvbmUuXG4gICAgICovXG4gICAgc3RhdGljIGRldGVybWluZUV4dGVybmFsUmVxdWVzdChcbiAgICAgICAgcmVxdWVzdDpzdHJpbmcsIGNvbnRleHQ6c3RyaW5nID0gJy4vJywgcmVxdWVzdENvbnRleHQ6c3RyaW5nID0gJy4vJyxcbiAgICAgICAgbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uOk5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbiA9IHt9LFxuICAgICAgICBleHRlcm5hbE1vZHVsZUxvY2F0aW9uczpBcnJheTxzdHJpbmc+ID0gWydub2RlX21vZHVsZXMnXSxcbiAgICAgICAgYWxpYXNlczpQbGFpbk9iamVjdCA9IHt9LCBtb2R1bGVSZXBsYWNlbWVudHM6UGxhaW5PYmplY3QgPSB7fSxcbiAgICAgICAgZXh0ZW5zaW9uczpFeHRlbnNpb25zID0ge1xuICAgICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsOiBbJy5qcyddLFxuICAgICAgICAgICAgICAgIGludGVybmFsOiBbXG4gICAgICAgICAgICAgICAgICAgICcuanMnLCAnLmpzb24nLCAnLmNzcycsICcuZW90JywgJy5naWYnLCAnLmh0bWwnLCAnLmljbycsXG4gICAgICAgICAgICAgICAgICAgICcuanBnJywgJy5wbmcnLCAnLmVqcycsICcuc3ZnJywgJy50dGYnLCAnLndvZmYnLCAnLndvZmYyJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIG1vZHVsZTogW11cbiAgICAgICAgfSwgcmVmZXJlbmNlUGF0aDpzdHJpbmcgPSAnLi8nLCBwYXRoc1RvSWdub3JlOkFycmF5PHN0cmluZz4gPSBbJy5naXQnXSxcbiAgICAgICAgcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHM6QXJyYXk8c3RyaW5nPiA9IFsnbm9kZV9tb2R1bGVzJ10sXG4gICAgICAgIHBhY2thZ2VFbnRyeUZpbGVOYW1lczpBcnJheTxzdHJpbmc+ID0gWydpbmRleCcsICdtYWluJ10sXG4gICAgICAgIHBhY2thZ2VNYWluUHJvcGVydHlOYW1lczpBcnJheTxzdHJpbmc+ID0gWydtYWluJywgJ21vZHVsZSddLFxuICAgICAgICBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzOkFycmF5PHN0cmluZz4gPSBbXSxcbiAgICAgICAgaW5jbHVkZVBhdHRlcm46QXJyYXk8c3RyaW5nfFJlZ0V4cD4gPSBbXSxcbiAgICAgICAgZXhjbHVkZVBhdHRlcm46QXJyYXk8c3RyaW5nfFJlZ0V4cD4gPSBbXSxcbiAgICAgICAgaW5QbGFjZU5vcm1hbExpYnJhcnk6Ym9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBpblBsYWNlRHluYW1pY0xpYnJhcnk6Ym9vbGVhbiA9IHRydWUsXG4gICAgICAgIGVuY29kaW5nOnN0cmluZyA9ICd1dGYtOCdcbiAgICApOj9zdHJpbmcge1xuICAgICAgICBjb250ZXh0ID0gcGF0aC5yZXNvbHZlKGNvbnRleHQpXG4gICAgICAgIHJlcXVlc3RDb250ZXh0ID0gcGF0aC5yZXNvbHZlKHJlcXVlc3RDb250ZXh0KVxuICAgICAgICByZWZlcmVuY2VQYXRoID0gcGF0aC5yZXNvbHZlKHJlZmVyZW5jZVBhdGgpXG4gICAgICAgIC8vIE5PVEU6IFdlIGFwcGx5IGFsaWFzIG9uIGV4dGVybmFscyBhZGRpdGlvbmFsbHkuXG4gICAgICAgIGxldCByZXNvbHZlZFJlcXVlc3Q6c3RyaW5nID0gSGVscGVyLmFwcGx5TW9kdWxlUmVwbGFjZW1lbnRzKFxuICAgICAgICAgICAgSGVscGVyLmFwcGx5QWxpYXNlcyhyZXF1ZXN0LnN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lmxhc3RJbmRleE9mKCchJykgKyAxXG4gICAgICAgICAgICApLCBhbGlhc2VzKSwgbW9kdWxlUmVwbGFjZW1lbnRzKVxuICAgICAgICAvKlxuICAgICAgICAgICAgTk9URTogQWxpYXNlcyBhbmQgbW9kdWxlIHJlcGxhY2VtZW50cyBkb2Vzbid0IGhhdmUgdG8gYmUgZm9yd2FyZGVkXG4gICAgICAgICAgICBzaW5jZSB3ZSBwYXNzIGFuIGFscmVhZHkgcmVzb2x2ZWQgcmVxdWVzdC5cbiAgICAgICAgKi9cbiAgICAgICAgbGV0IGZpbGVQYXRoOj9zdHJpbmcgPSBIZWxwZXIuZGV0ZXJtaW5lTW9kdWxlRmlsZVBhdGgoXG4gICAgICAgICAgICByZXNvbHZlZFJlcXVlc3QsIHt9LCB7fSwgZXh0ZW5zaW9ucywgY29udGV4dCwgcmVxdWVzdENvbnRleHQsXG4gICAgICAgICAgICBwYXRoc1RvSWdub3JlLCByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocywgcGFja2FnZUVudHJ5RmlsZU5hbWVzLFxuICAgICAgICAgICAgcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzLCBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzLCBlbmNvZGluZylcbiAgICAgICAgLypcbiAgICAgICAgICAgIE5PVEU6IFdlIG1hcmsgZGVwZW5kZW5jaWVzIGFzIGV4dGVybmFsIGlmIHRoZXJlIGZpbGUgY291bGRuJ3QgYmVcbiAgICAgICAgICAgIHJlc29sdmVkIG9yIGFyZSBzcGVjaWZpZWQgdG8gYmUgZXh0ZXJuYWwgZXhwbGljaXRseS5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCEoZmlsZVBhdGggfHwgaW5QbGFjZU5vcm1hbExpYnJhcnkpIHx8IFRvb2xzLmlzQW55TWF0Y2hpbmcoXG4gICAgICAgICAgICByZXNvbHZlZFJlcXVlc3QsIGluY2x1ZGVQYXR0ZXJuXG4gICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm4gSGVscGVyLmFwcGx5Q29udGV4dChcbiAgICAgICAgICAgICAgICByZXNvbHZlZFJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCByZWZlcmVuY2VQYXRoLFxuICAgICAgICAgICAgICAgIGFsaWFzZXMsIG1vZHVsZVJlcGxhY2VtZW50cywgcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHMpXG4gICAgICAgIGlmIChUb29scy5pc0FueU1hdGNoaW5nKHJlc29sdmVkUmVxdWVzdCwgZXhjbHVkZVBhdHRlcm4pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgZm9yIChjb25zdCBjaHVua05hbWU6c3RyaW5nIGluIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbilcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24uaGFzT3duUHJvcGVydHkoY2h1bmtOYW1lKSlcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUlEOnN0cmluZyBvZiBub3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb25bXG4gICAgICAgICAgICAgICAgICAgIGNodW5rTmFtZVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXIuZGV0ZXJtaW5lTW9kdWxlRmlsZVBhdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVJRCwgYWxpYXNlcywgbW9kdWxlUmVwbGFjZW1lbnRzLCBleHRlbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgcmVxdWVzdENvbnRleHQsIHBhdGhzVG9JZ25vcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocywgcGFja2FnZUVudHJ5RmlsZU5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzLCBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmdcbiAgICAgICAgICAgICAgICAgICAgKSA9PT0gZmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAvKlxuICAgICAgICAgICAgTk9URTogV2UgbWFyayBkZXBlbmRlbmNpZXMgYXMgZXh0ZXJuYWwgaWYgdGhleSBkb2VzIG5vdCBjb250YWluIGFcbiAgICAgICAgICAgIGxvYWRlciBpbiB0aGVpciByZXF1ZXN0IGFuZCBhcmVuJ3QgcGFydCBvZiB0aGUgY3VycmVudCBtYWluIHBhY2thZ2VcbiAgICAgICAgICAgIG9yIGhhdmUgYSBmaWxlIGV4dGVuc2lvbiBvdGhlciB0aGFuIGphdmFTY3JpcHQgYXdhcmUuXG4gICAgICAgICovXG4gICAgICAgIGlmICghaW5QbGFjZU5vcm1hbExpYnJhcnkgJiYgKFxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5maWxlLmV4dGVybmFsLmxlbmd0aCA9PT0gMCB8fCBmaWxlUGF0aCAmJlxuICAgICAgICAgICAgZXh0ZW5zaW9ucy5maWxlLmV4dGVybmFsLmluY2x1ZGVzKHBhdGguZXh0bmFtZShmaWxlUGF0aCkpIHx8XG4gICAgICAgICAgICAhZmlsZVBhdGggJiYgZXh0ZW5zaW9ucy5maWxlLmV4dGVybmFsLmluY2x1ZGVzKCcnKVxuICAgICAgICApICYmICEoaW5QbGFjZUR5bmFtaWNMaWJyYXJ5ICYmIHJlcXVlc3QuaW5jbHVkZXMoJyEnKSkgJiYgKFxuICAgICAgICAgICAgICAgICFmaWxlUGF0aCAmJiBpblBsYWNlRHluYW1pY0xpYnJhcnkgfHwgZmlsZVBhdGggJiYgKFxuICAgICAgICAgICAgICAgICAgICAhZmlsZVBhdGguc3RhcnRzV2l0aChjb250ZXh0KSB8fFxuICAgICAgICAgICAgICAgICAgICBIZWxwZXIuaXNGaWxlUGF0aEluTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aCwgZXh0ZXJuYWxNb2R1bGVMb2NhdGlvbnMpKVxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gSGVscGVyLmFwcGx5Q29udGV4dChcbiAgICAgICAgICAgICAgICByZXNvbHZlZFJlcXVlc3QsIHJlcXVlc3RDb250ZXh0LCByZWZlcmVuY2VQYXRoLCBhbGlhc2VzLFxuICAgICAgICAgICAgICAgIG1vZHVsZVJlcGxhY2VtZW50cywgcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHMpXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYXNzZXQgdHlwZSBvZiBnaXZlbiBmaWxlLlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFBhdGggdG8gZmlsZSB0byBhbmFseXNlLlxuICAgICAqIEBwYXJhbSBidWlsZENvbmZpZ3VyYXRpb24gLSBNZXRhIGluZm9ybWF0aW9ucyBmb3IgYXZhaWxhYmxlIGFzc2V0XG4gICAgICogdHlwZXMuXG4gICAgICogQHBhcmFtIHBhdGhzIC0gTGlzdCBvZiBwYXRocyB0byBzZWFyY2ggaWYgZ2l2ZW4gcGF0aCBkb2Vzbid0IHJlZmVyZW5jZVxuICAgICAqIGEgZmlsZSBkaXJlY3RseS5cbiAgICAgKiBAcmV0dXJucyBEZXRlcm1pbmVkIGZpbGUgdHlwZSBvciBcIm51bGxcIiBvZiBnaXZlbiBmaWxlIGNvdWxkbid0IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZXJtaW5lQXNzZXRUeXBlKFxuICAgICAgICBmaWxlUGF0aDpzdHJpbmcsIGJ1aWxkQ29uZmlndXJhdGlvbjpCdWlsZENvbmZpZ3VyYXRpb24sIHBhdGhzOlBhdGhcbiAgICApOj9zdHJpbmcge1xuICAgICAgICBsZXQgcmVzdWx0Oj9zdHJpbmcgPSBudWxsXG4gICAgICAgIGZvciAoY29uc3QgdHlwZTpzdHJpbmcgaW4gYnVpbGRDb25maWd1cmF0aW9uKVxuICAgICAgICAgICAgaWYgKHBhdGguZXh0bmFtZShcbiAgICAgICAgICAgICAgICBmaWxlUGF0aFxuICAgICAgICAgICAgKSA9PT0gYC4ke2J1aWxkQ29uZmlndXJhdGlvblt0eXBlXS5leHRlbnNpb259YCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHR5cGVcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZTpzdHJpbmcgb2YgWydzb3VyY2UnLCAndGFyZ2V0J10pXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhc3NldFR5cGU6c3RyaW5nIGluIHBhdGhzW3R5cGVdLmFzc2V0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoc1t0eXBlXS5hc3NldC5oYXNPd25Qcm9wZXJ0eShhc3NldFR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NldFR5cGUgIT09ICdiYXNlJyAmJiBwYXRoc1t0eXBlXS5hc3NldFthc3NldFR5cGVdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aC5zdGFydHNXaXRoKHBhdGhzW3R5cGVdLmFzc2V0W2Fzc2V0VHlwZV0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3NldFR5cGVcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJvcGVydHkgd2l0aCBhIHN0b3JlZCBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgZmlsZSBwYXRocywgd2hpY2hcbiAgICAgKiBtYXRjaGVzIGVhY2ggYnVpbGQgY29uZmlndXJhdGlvbiBpbiBnaXZlbiBlbnRyeSBwYXRoIGFuZCBjb252ZXJ0cyBnaXZlblxuICAgICAqIGJ1aWxkIGNvbmZpZ3VyYXRpb24gaW50byBhIHNvcnRlZCBhcnJheSB3ZXJlIGphdmFTY3JpcHQgZmlsZXMgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqIEBwYXJhbSBjb25maWd1cmF0aW9uIC0gR2l2ZW4gYnVpbGQgY29uZmlndXJhdGlvbnMuXG4gICAgICogQHBhcmFtIGVudHJ5UGF0aCAtIFBhdGggdG8gYW5hbHlzZSBuZXN0ZWQgc3RydWN0dXJlLlxuICAgICAqIEBwYXJhbSBwYXRoc1RvSWdub3JlIC0gUGF0aHMgd2hpY2ggbWFya3MgbG9jYXRpb24gdG8gaWdub3JlLlxuICAgICAqIEBwYXJhbSBtYWluRmlsZUJhc2VuYW1lcyAtIEZpbGUgYmFzZW5hbWVzIHRvIHNvcnQgaW50byB0aGUgZnJvbnQuXG4gICAgICogQHJldHVybnMgQ29udmVydGVkIGJ1aWxkIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmVCdWlsZENvbmZpZ3VyYXRpb25GaWxlUGF0aHMoXG4gICAgICAgIGNvbmZpZ3VyYXRpb246QnVpbGRDb25maWd1cmF0aW9uLCBlbnRyeVBhdGg6c3RyaW5nID0gJy4vJyxcbiAgICAgICAgcGF0aHNUb0lnbm9yZTpBcnJheTxzdHJpbmc+ID0gWycuZ2l0J10sXG4gICAgICAgIG1haW5GaWxlQmFzZW5hbWVzOkFycmF5PHN0cmluZz4gPSBbJ2luZGV4JywgJ21haW4nXVxuICAgICk6UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb24ge1xuICAgICAgICBjb25zdCBidWlsZENvbmZpZ3VyYXRpb246UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb24gPSBbXVxuICAgICAgICBmb3IgKGNvbnN0IHR5cGU6c3RyaW5nIGluIGNvbmZpZ3VyYXRpb24pXG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW06UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb25JdGVtID1cbiAgICAgICAgICAgICAgICAgICAgVG9vbHMuZXh0ZW5kT2JqZWN0KHRydWUsIHtmaWxlUGF0aHM6IFtdfSwgY29uZmlndXJhdGlvbltcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVdKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZTpGaWxlIG9mIFRvb2xzLndhbGtEaXJlY3RvcnlSZWN1cnNpdmVseVN5bmMoXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5UGF0aCwgKGZpbGU6RmlsZSk6P2ZhbHNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXIuaXNGaWxlUGF0aEluTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5wYXRoLCBwYXRoc1RvSWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS5zdGF0LmlzRmlsZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmV4dG5hbWUoZmlsZS5wYXRoKS5zdWJzdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgKSA9PT0gbmV3SXRlbS5leHRlbnNpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEobmV3IFJlZ0V4cChuZXdJdGVtLmZpbGVQYXRoUGF0dGVybikpLnRlc3QoZmlsZS5wYXRoKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLmZpbGVQYXRocy5wdXNoKGZpbGUucGF0aClcbiAgICAgICAgICAgICAgICBuZXdJdGVtLmZpbGVQYXRocy5zb3J0KChcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RGaWxlUGF0aDpzdHJpbmcsIHNlY29uZEZpbGVQYXRoOnN0cmluZ1xuICAgICAgICAgICAgICAgICk6bnVtYmVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5GaWxlQmFzZW5hbWVzLmluY2x1ZGVzKHBhdGguYmFzZW5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEZpbGVQYXRoLCBwYXRoLmV4dG5hbWUoZmlyc3RGaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYWluRmlsZUJhc2VuYW1lcy5pbmNsdWRlcyhwYXRoLmJhc2VuYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEZpbGVQYXRoLCBwYXRoLmV4dG5hbWUoc2Vjb25kRmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1haW5GaWxlQmFzZW5hbWVzLmluY2x1ZGVzKHBhdGguYmFzZW5hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRGaWxlUGF0aCwgcGF0aC5leHRuYW1lKHNlY29uZEZpbGVQYXRoKVxuICAgICAgICAgICAgICAgICAgICApKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb24ucHVzaChuZXdJdGVtKVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRDb25maWd1cmF0aW9uLnNvcnQoKFxuICAgICAgICAgICAgZmlyc3Q6UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb25JdGVtLFxuICAgICAgICAgICAgc2Vjb25kOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uSXRlbVxuICAgICAgICApOm51bWJlciA9PiB7XG4gICAgICAgICAgICBpZiAoZmlyc3Qub3V0cHV0RXh0ZW5zaW9uICE9PSBzZWNvbmQub3V0cHV0RXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Lm91dHB1dEV4dGVuc2lvbiA9PT0gJ2pzJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICAgICAgaWYgKHNlY29uZC5vdXRwdXRFeHRlbnNpb24gPT09ICdqcycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0Lm91dHB1dEV4dGVuc2lvbiA8IHNlY29uZC5vdXRwdXRFeHRlbnNpb24gPyAtMSA6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYWxsIGZpbGUgYW5kIGRpcmVjdG9yeSBwYXRocyByZWxhdGVkIHRvIGdpdmVuIGludGVybmFsXG4gICAgICogbW9kdWxlcyBhcyBhcnJheS5cbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxJbmplY3Rpb24gLSBMaXN0IG9mIG1vZHVsZSBpZHMgb3IgbW9kdWxlIGZpbGUgcGF0aHMuXG4gICAgICogQHBhcmFtIGFsaWFzZXMgLSBNYXBwaW5nIG9mIGFsaWFzZXMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIG1vZHVsZVJlcGxhY2VtZW50cyAtIE1hcHBpbmcgb2YgbW9kdWxlIHJlcGxhY2VtZW50cyB0byB0YWtlIGludG9cbiAgICAgKiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIC0gTGlzdCBvZiBmaWxlIGFuZCBtb2R1bGUgZXh0ZW5zaW9ucyB0byB0YWtlIGludG9cbiAgICAgKiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gRmlsZSBwYXRoIHRvIHJlc29sdmUgcmVsYXRpdmUgdG8uXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZVBhdGggLSBQYXRoIHRvIHNlYXJjaCBmb3IgbG9jYWwgbW9kdWxlcy5cbiAgICAgKiBAcGFyYW0gcGF0aHNUb0lnbm9yZSAtIFBhdGhzIHdoaWNoIG1hcmtzIGxvY2F0aW9uIHRvIGlnbm9yZS5cbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHMgLSBMaXN0IG9mIHJlbGF0aXZlIGZpbGUgcGF0aCB0byBzZWFyY2hcbiAgICAgKiBmb3IgbW9kdWxlcyBpbi5cbiAgICAgKiBAcGFyYW0gcGFja2FnZUVudHJ5RmlsZU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGVudHJ5IGZpbGUgbmFtZXMgdG9cbiAgICAgKiBzZWFyY2ggZm9yLiBUaGUgbWFnaWMgbmFtZSBcIl9fcGFja2FnZV9fXCIgd2lsbCBzZWFyY2ggZm9yIGFuIGFwcHJlY2lhdGVcbiAgICAgKiBlbnRyeSBpbiBhIFwicGFja2FnZS5qc29uXCIgZmlsZS5cbiAgICAgKiBAcGFyYW0gcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGZpbGUgbWFpbiBwcm9wZXJ0eVxuICAgICAqIG5hbWVzIHRvIHNlYXJjaCBmb3IgcGFja2FnZSByZXByZXNlbnRpbmcgZW50cnkgbW9kdWxlIGRlZmluaXRpb25zLlxuICAgICAqIEBwYXJhbSBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzIC0gTGlzdCBvZiBwYWNrYWdlIGZpbGUgYWxpYXMgcHJvcGVydHlcbiAgICAgKiBuYW1lcyB0byBzZWFyY2ggZm9yIHBhY2thZ2Ugc3BlY2lmaWMgbW9kdWxlIGFsaWFzZXMuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIC0gRmlsZSBuYW1lIGVuY29kaW5nIHRvIHVzZSBkdXJpbmcgZmlsZSB0cmF2ZXJzaW5nLlxuICAgICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGEgZmlsZSBwYXRoIGFuZCBkaXJlY3RvcnkgcGF0aCBrZXkgbWFwcGluZyB0b1xuICAgICAqIGNvcnJlc3BvbmRpbmcgbGlzdCBvZiBwYXRocy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGV0ZXJtaW5lTW9kdWxlTG9jYXRpb25zKFxuICAgICAgICBpbnRlcm5hbEluamVjdGlvbjpJbnRlcm5hbEluamVjdGlvbiwgYWxpYXNlczpQbGFpbk9iamVjdCA9IHt9LFxuICAgICAgICBtb2R1bGVSZXBsYWNlbWVudHM6UGxhaW5PYmplY3QgPSB7fSwgZXh0ZW5zaW9uczpFeHRlbnNpb25zID0ge1xuICAgICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsOiBbJy5qcyddLFxuICAgICAgICAgICAgICAgIGludGVybmFsOiBbXG4gICAgICAgICAgICAgICAgICAgICcuanMnLCAnLmpzb24nLCAnLmNzcycsICcuZW90JywgJy5naWYnLCAnLmh0bWwnLCAnLmljbycsXG4gICAgICAgICAgICAgICAgICAgICcuanBnJywgJy5wbmcnLCAnLmVqcycsICcuc3ZnJywgJy50dGYnLCAnLndvZmYnLCAnLndvZmYyJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sIG1vZHVsZTogW11cbiAgICAgICAgfSwgY29udGV4dDpzdHJpbmcgPSAnLi8nLCByZWZlcmVuY2VQYXRoOnN0cmluZyA9ICcnLFxuICAgICAgICBwYXRoc1RvSWdub3JlOkFycmF5PHN0cmluZz4gPSBbJy5naXQnXSxcbiAgICAgICAgcmVsYXRpdmVNb2R1bGVGaWxlUGF0aHM6QXJyYXk8c3RyaW5nPiA9IFsnJywgJ25vZGVfbW9kdWxlcycsICcuLi8nXSxcbiAgICAgICAgcGFja2FnZUVudHJ5RmlsZU5hbWVzOkFycmF5PHN0cmluZz4gPSBbXG4gICAgICAgICAgICAnX19wYWNrYWdlX18nLCAnJywgJ2luZGV4JywgJ21haW4nXSxcbiAgICAgICAgcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzOkFycmF5PHN0cmluZz4gPSBbJ21haW4nLCAnbW9kdWxlJ10sXG4gICAgICAgIHBhY2thZ2VBbGlhc1Byb3BlcnR5TmFtZXM6QXJyYXk8c3RyaW5nPiA9IFtdLFxuICAgICAgICBlbmNvZGluZzpzdHJpbmcgPSAndXRmLTgnXG4gICAgKTp7ZmlsZVBhdGhzOkFycmF5PHN0cmluZz47ZGlyZWN0b3J5UGF0aHM6QXJyYXk8c3RyaW5nPn0ge1xuICAgICAgICBjb25zdCBmaWxlUGF0aHM6QXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgICAgIGNvbnN0IGRpcmVjdG9yeVBhdGhzOkFycmF5PHN0cmluZz4gPSBbXVxuICAgICAgICBjb25zdCBub3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb246Tm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uID1cbiAgICAgICAgICAgIEhlbHBlci5yZXNvbHZlTW9kdWxlc0luRm9sZGVycyhcbiAgICAgICAgICAgICAgICBIZWxwZXIubm9ybWFsaXplSW50ZXJuYWxJbmplY3Rpb24oaW50ZXJuYWxJbmplY3Rpb24pLFxuICAgICAgICAgICAgICAgIGFsaWFzZXMsIG1vZHVsZVJlcGxhY2VtZW50cywgY29udGV4dCwgcmVmZXJlbmNlUGF0aCxcbiAgICAgICAgICAgICAgICBwYXRoc1RvSWdub3JlKVxuICAgICAgICBmb3IgKGNvbnN0IGNodW5rTmFtZTpzdHJpbmcgaW4gbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uKVxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShjaHVua05hbWUpKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbW9kdWxlSUQ6c3RyaW5nIG9mIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbltcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtOYW1lXG4gICAgICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlUGF0aDo/c3RyaW5nID0gSGVscGVyLmRldGVybWluZU1vZHVsZUZpbGVQYXRoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlSUQsIGFsaWFzZXMsIG1vZHVsZVJlcGxhY2VtZW50cywgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHJlZmVyZW5jZVBhdGgsIHBhdGhzVG9JZ25vcmUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocywgcGFja2FnZUVudHJ5RmlsZU5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZU1haW5Qcm9wZXJ0eU5hbWVzLCBwYWNrYWdlQWxpYXNQcm9wZXJ0eU5hbWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGhzLnB1c2goZmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3RvcnlQYXRoOnN0cmluZyA9IHBhdGguZGlybmFtZShmaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlyZWN0b3J5UGF0aHMuaW5jbHVkZXMoZGlyZWN0b3J5UGF0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5UGF0aHMucHVzaChkaXJlY3RvcnlQYXRoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2ZpbGVQYXRocywgZGlyZWN0b3J5UGF0aHN9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYSBsaXN0IG9mIGNvbmNyZXRlIGZpbGUgcGF0aHMgZm9yIGdpdmVuIG1vZHVsZSBpZCBwb2ludGluZyB0b1xuICAgICAqIGEgZm9sZGVyIHdoaWNoIGlzbid0IGEgcGFja2FnZS5cbiAgICAgKiBAcGFyYW0gbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uIC0gSW5qZWN0aW9uIGRhdGEgc3RydWN0dXJlIG9mXG4gICAgICogbW9kdWxlcyB3aXRoIGZvbGRlciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIGFsaWFzZXMgLSBNYXBwaW5nIG9mIGFsaWFzZXMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIG1vZHVsZVJlcGxhY2VtZW50cyAtIE1hcHBpbmcgb2YgcmVwbGFjZW1lbnRzIHRvIHRha2UgaW50b1xuICAgICAqIGFjY291bnQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBGaWxlIHBhdGggdG8gZGV0ZXJtaW5lIHJlbGF0aXZlIHRvLlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VQYXRoIC0gUGF0aCB0byByZXNvbHZlIGxvY2FsIG1vZHVsZXMgcmVsYXRpdmUgdG8uXG4gICAgICogQHBhcmFtIHBhdGhzVG9JZ25vcmUgLSBQYXRocyB3aGljaCBtYXJrcyBsb2NhdGlvbiB0byBpZ25vcmUuXG4gICAgICogQHJldHVybnMgR2l2ZW4gaW5qZWN0aW9ucyB3aXRoIHJlc29sdmVkIGZvbGRlciBwb2ludGluZyBtb2R1bGVzLlxuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlTW9kdWxlc0luRm9sZGVycyhcbiAgICAgICAgbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uOk5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbixcbiAgICAgICAgYWxpYXNlczpQbGFpbk9iamVjdCA9IHt9LCBtb2R1bGVSZXBsYWNlbWVudHM6UGxhaW5PYmplY3QgPSB7fSxcbiAgICAgICAgY29udGV4dDpzdHJpbmcgPSAnLi8nLCByZWZlcmVuY2VQYXRoOnN0cmluZyA9ICcnLFxuICAgICAgICBwYXRoc1RvSWdub3JlOkFycmF5PHN0cmluZz4gPSBbJy5naXQnXVxuICAgICk6Tm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uIHtcbiAgICAgICAgaWYgKHJlZmVyZW5jZVBhdGguc3RhcnRzV2l0aCgnLycpKVxuICAgICAgICAgICAgcmVmZXJlbmNlUGF0aCA9IHBhdGgucmVsYXRpdmUoY29udGV4dCwgcmVmZXJlbmNlUGF0aClcbiAgICAgICAgZm9yIChjb25zdCBjaHVua05hbWU6c3RyaW5nIGluIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbilcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24uaGFzT3duUHJvcGVydHkoY2h1bmtOYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmRleDpudW1iZXIgPSAwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbW9kdWxlSUQ6c3RyaW5nIG9mIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbltcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtOYW1lXG4gICAgICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IEhlbHBlci5hcHBseU1vZHVsZVJlcGxhY2VtZW50cyhcbiAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBlci5hcHBseUFsaWFzZXMoSGVscGVyLnN0cmlwTG9hZGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUlEXG4gICAgICAgICAgICAgICAgICAgICAgICApLCBhbGlhc2VzKSwgbW9kdWxlUmVwbGFjZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGg6c3RyaW5nID0gcGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlUGF0aCwgbW9kdWxlSUQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChUb29scy5pc0RpcmVjdG9yeVN5bmMocmVzb2x2ZWRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uW2NodW5rTmFtZV0uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlOkZpbGUgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb29scy53YWxrRGlyZWN0b3J5UmVjdXJzaXZlbHlTeW5jKHJlc29sdmVkUGF0aCwgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlOkZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApOj9mYWxzZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXIuaXNGaWxlUGF0aEluTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLnBhdGgsIHBhdGhzVG9JZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuc3RhdC5pc0ZpbGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uW2NodW5rTmFtZV0ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuLycgKyBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVBhdGgsIHBhdGgucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoLCBmaWxlLnBhdGgpKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUlELnN0YXJ0c1dpdGgoJy4vJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFtb2R1bGVJRC5zdGFydHNXaXRoKCcuLycgKyBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsIHJlZmVyZW5jZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnRlcm5hbEluamVjdGlvbltjaHVua05hbWVdW2luZGV4XSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYC4vJHtwYXRoLnJlbGF0aXZlKGNvbnRleHQsIHJlc29sdmVkUGF0aCl9YFxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGluamVjdGlvbiBkZWZpbml0aW9uIHR5cGUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIHBsYWluIG9iamVjdFxuICAgICAqIChtYXBwaW5nIGZyb20gY2h1bmsgbmFtZSB0byBhcnJheSBvZiBtb2R1bGUgaWRzKS4gVGhpcyBtZXRob2QgY29udmVydHNcbiAgICAgKiBlYWNoIHJlcHJlc2VudGF0aW9uIGludG8gdGhlIG5vcm1hbGl6ZWQgcGxhaW4gb2JqZWN0IG5vdGF0aW9uLlxuICAgICAqIEBwYXJhbSBpbnRlcm5hbEluamVjdGlvbiAtIEdpdmVuIGludGVybmFsIGluamVjdGlvbiB0byBub3JtYWxpemUuXG4gICAgICogQHJldHVybnMgTm9ybWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBnaXZlbiBpbnRlcm5hbCBpbmplY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZUludGVybmFsSW5qZWN0aW9uKFxuICAgICAgICBpbnRlcm5hbEluamVjdGlvbjpJbnRlcm5hbEluamVjdGlvblxuICAgICk6Tm9ybWFsaXplZEludGVybmFsSW5qZWN0aW9uIHtcbiAgICAgICAgbGV0IHJlc3VsdDpOb3JtYWxpemVkSW50ZXJuYWxJbmplY3Rpb24gPSB7fVxuICAgICAgICBpZiAoaW50ZXJuYWxJbmplY3Rpb24gaW5zdGFuY2VvZiBPYmplY3QgJiYgVG9vbHMuaXNQbGFpbk9iamVjdChcbiAgICAgICAgICAgIGludGVybmFsSW5qZWN0aW9uXG4gICAgICAgICkpIHtcbiAgICAgICAgICAgIGxldCBoYXNDb250ZW50OmJvb2xlYW4gPSBmYWxzZVxuICAgICAgICAgICAgY29uc3QgY2h1bmtOYW1lc1RvRGVsZXRlOkFycmF5PHN0cmluZz4gPSBbXVxuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVua05hbWU6c3RyaW5nIGluIGludGVybmFsSW5qZWN0aW9uKVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEluamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShjaHVua05hbWUpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnRlcm5hbEluamVjdGlvbltjaHVua05hbWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbEluamVjdGlvbltjaHVua05hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjaHVua05hbWVdID0gaW50ZXJuYWxJbmplY3Rpb25bY2h1bmtOYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtOYW1lc1RvRGVsZXRlLnB1c2goY2h1bmtOYW1lKVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRlbnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY2h1bmtOYW1lXSA9IFtpbnRlcm5hbEluamVjdGlvbltjaHVua05hbWVdXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ29udGVudClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rTmFtZTpzdHJpbmcgb2YgY2h1bmtOYW1lc1RvRGVsZXRlKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0W2NodW5rTmFtZV1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7aW5kZXg6IFtdfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnRlcm5hbEluamVjdGlvbiA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXN1bHQgPSB7aW5kZXg6IFtpbnRlcm5hbEluamVjdGlvbl19XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW50ZXJuYWxJbmplY3Rpb24pKVxuICAgICAgICAgICAgcmVzdWx0ID0ge2luZGV4OiBpbnRlcm5hbEluamVjdGlvbn1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGFsbCBjb25jcmV0ZSBmaWxlIHBhdGhzIGZvciBnaXZlbiBpbmplY3Rpb24gd2hpY2ggYXJlIG1hcmtlZFxuICAgICAqIHdpdGggdGhlIFwiX19hdXRvX19cIiBpbmRpY2F0b3IuXG4gICAgICogQHBhcmFtIGdpdmVuSW5qZWN0aW9uIC0gR2l2ZW4gaW50ZXJuYWwgYW5kIGV4dGVybmFsIGluamVjdGlvbiB0byB0YWtlXG4gICAgICogaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBidWlsZENvbmZpZ3VyYXRpb25zIC0gUmVzb2x2ZWQgYnVpbGQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbW9kdWxlc1RvRXhjbHVkZSAtIEEgbGlzdCBvZiBtb2R1bGVzIHRvIGV4Y2x1ZGUgKHNwZWNpZmllZCBieVxuICAgICAqIHBhdGggb3IgaWQpIG9yIGEgbWFwcGluZyBmcm9tIGNodW5rIG5hbWVzIHRvIG1vZHVsZSBpZHMuXG4gICAgICogQHBhcmFtIGFsaWFzZXMgLSBNYXBwaW5nIG9mIGFsaWFzZXMgdG8gdGFrZSBpbnRvIGFjY291bnQuXG4gICAgICogQHBhcmFtIG1vZHVsZVJlcGxhY2VtZW50cyAtIE1hcHBpbmcgb2YgcmVwbGFjZW1lbnRzIHRvIHRha2UgaW50b1xuICAgICAqIGFjY291bnQuXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbnMgLSBMaXN0IG9mIGZpbGUgYW5kIG1vZHVsZSBleHRlbnNpb25zIHRvIHRha2UgaW50b1xuICAgICAqIGFjY291bnQuXG4gICAgICogQHBhcmFtIGNvbnRleHQgLSBGaWxlIHBhdGggdG8gdXNlIGFzIHN0YXJ0aW5nIHBvaW50LlxuICAgICAqIEBwYXJhbSByZWZlcmVuY2VQYXRoIC0gUmVmZXJlbmNlIHBhdGggZnJvbSB3aGVyZSBsb2NhbCBmaWxlcyBzaG91bGQgYmVcbiAgICAgKiByZXNvbHZlZC5cbiAgICAgKiBAcGFyYW0gcGF0aHNUb0lnbm9yZSAtIFBhdGhzIHdoaWNoIG1hcmtzIGxvY2F0aW9uIHRvIGlnbm9yZS5cbiAgICAgKiBAcmV0dXJucyBHaXZlbiBpbmplY3Rpb24gd2l0aCByZXNvbHZlZCBtYXJrZWQgaW5kaWNhdG9ycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUluamVjdGlvbihcbiAgICAgICAgZ2l2ZW5JbmplY3Rpb246SW5qZWN0aW9uLFxuICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25zOlJlc29sdmVkQnVpbGRDb25maWd1cmF0aW9uLFxuICAgICAgICBtb2R1bGVzVG9FeGNsdWRlOkludGVybmFsSW5qZWN0aW9uLFxuICAgICAgICBhbGlhc2VzOlBsYWluT2JqZWN0ID0ge30sIG1vZHVsZVJlcGxhY2VtZW50czpQbGFpbk9iamVjdCA9IHt9LFxuICAgICAgICBleHRlbnNpb25zOkV4dGVuc2lvbnMgPSB7XG4gICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IFsnLmpzJ10sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IFtcbiAgICAgICAgICAgICAgICAgICAgJy5qcycsICcuanNvbicsICcuY3NzJywgJy5lb3QnLCAnLmdpZicsICcuaHRtbCcsICcuaWNvJyxcbiAgICAgICAgICAgICAgICAgICAgJy5qcGcnLCAnLnBuZycsICcuZWpzJywgJy5zdmcnLCAnLnR0ZicsICcud29mZicsICcud29mZjInXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgbW9kdWxlOiBbXVxuICAgICAgICB9LCBjb250ZXh0OnN0cmluZyA9ICcuLycsIHJlZmVyZW5jZVBhdGg6c3RyaW5nID0gJycsXG4gICAgICAgIHBhdGhzVG9JZ25vcmU6QXJyYXk8c3RyaW5nPiA9IFsnLmdpdCddXG4gICAgKTpJbmplY3Rpb24ge1xuICAgICAgICBjb25zdCBpbmplY3Rpb246SW5qZWN0aW9uID0gVG9vbHMuZXh0ZW5kT2JqZWN0KFxuICAgICAgICAgICAgdHJ1ZSwge30sIGdpdmVuSW5qZWN0aW9uKVxuICAgICAgICBjb25zdCBtb2R1bGVGaWxlUGF0aHNUb0V4Y2x1ZGU6QXJyYXk8c3RyaW5nPiA9XG4gICAgICAgICAgICBIZWxwZXIuZGV0ZXJtaW5lTW9kdWxlTG9jYXRpb25zKFxuICAgICAgICAgICAgICAgIG1vZHVsZXNUb0V4Y2x1ZGUsIGFsaWFzZXMsIG1vZHVsZVJlcGxhY2VtZW50cywgZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LCByZWZlcmVuY2VQYXRoLCBwYXRoc1RvSWdub3JlXG4gICAgICAgICAgICApLmZpbGVQYXRoc1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGU6c3RyaW5nIG9mIFsnaW50ZXJuYWwnLCAnZXh0ZXJuYWwnXSlcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGN1cmx5ICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluamVjdGlvblt0eXBlXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rTmFtZTpzdHJpbmcgaW4gaW5qZWN0aW9uW3R5cGVdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5qZWN0aW9uW3R5cGVdW2NodW5rTmFtZV0gPT09ICdfX2F1dG9fXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGlvblt0eXBlXVtjaHVua05hbWVdID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZHVsZXM6e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtrZXk6c3RyaW5nXTpzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gPSBIZWxwZXIuZ2V0QXV0b0NodW5rKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbnMsIG1vZHVsZUZpbGVQYXRoc1RvRXhjbHVkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VQYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdWJDaHVua05hbWU6c3RyaW5nIGluIG1vZHVsZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZHVsZXMuaGFzT3duUHJvcGVydHkoc3ViQ2h1bmtOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5qZWN0aW9uW3R5cGVdW2NodW5rTmFtZV0ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZXNbc3ViQ2h1bmtOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmV2ZXJzZSBhcnJheSB0byBsZXQgamF2YVNjcmlwdCBhbmQgbWFpbiBmaWxlcyBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBsYXN0IG9uZXMgdG8gZXhwb3J0IHRoZW0gcmF0aGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGlvblt0eXBlXVtjaHVua05hbWVdLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluamVjdGlvblt0eXBlXSA9PT0gJ19fYXV0b19fJylcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgY3VybHkgKi9cbiAgICAgICAgICAgICAgICBpbmplY3Rpb25bdHlwZV0gPSBIZWxwZXIuZ2V0QXV0b0NodW5rKFxuICAgICAgICAgICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25zLCBtb2R1bGVGaWxlUGF0aHNUb0V4Y2x1ZGUsIGNvbnRleHQpXG4gICAgICAgIHJldHVybiBpbmplY3Rpb25cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhbGwgbW9kdWxlIGZpbGUgcGF0aHMuXG4gICAgICogQHBhcmFtIGJ1aWxkQ29uZmlndXJhdGlvbnMgLSBSZXNvbHZlZCBidWlsZCBjb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBtb2R1bGVGaWxlUGF0aHNUb0V4Y2x1ZGUgLSBBIGxpc3Qgb2YgbW9kdWxlcyBmaWxlIHBhdGhzIHRvXG4gICAgICogZXhjbHVkZSAoc3BlY2lmaWVkIGJ5IHBhdGggb3IgaWQpIG9yIGEgbWFwcGluZyBmcm9tIGNodW5rIG5hbWVzIHRvXG4gICAgICogbW9kdWxlIGlkcy5cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIEZpbGUgcGF0aCB0byB1c2UgYXMgc3RhcnRpbmcgcG9pbnQuXG4gICAgICogQHJldHVybnMgQWxsIGRldGVybWluZWQgbW9kdWxlIGZpbGUgcGF0aHMuXG4gICAgICovXG4gICAgc3RhdGljIGdldEF1dG9DaHVuayhcbiAgICAgICAgYnVpbGRDb25maWd1cmF0aW9uczpSZXNvbHZlZEJ1aWxkQ29uZmlndXJhdGlvbixcbiAgICAgICAgbW9kdWxlRmlsZVBhdGhzVG9FeGNsdWRlOkFycmF5PHN0cmluZz4sIGNvbnRleHQ6c3RyaW5nXG4gICAgKTp7W2tleTpzdHJpbmddOnN0cmluZ30ge1xuICAgICAgICBjb25zdCByZXN1bHQ6e1trZXk6c3RyaW5nXTpzdHJpbmd9ID0ge31cbiAgICAgICAgY29uc3QgaW5qZWN0ZWRNb2R1bGVJRHM6e1trZXk6c3RyaW5nXTpBcnJheTxzdHJpbmc+fSA9IHt9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICBjb25zdCBidWlsZENvbmZpZ3VyYXRpb246UmVzb2x2ZWRCdWlsZENvbmZpZ3VyYXRpb25JdGVtIG9mXG4gICAgICAgICAgICBidWlsZENvbmZpZ3VyYXRpb25zXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCFpbmplY3RlZE1vZHVsZUlEc1tidWlsZENvbmZpZ3VyYXRpb24ub3V0cHV0RXh0ZW5zaW9uXSlcbiAgICAgICAgICAgICAgICBpbmplY3RlZE1vZHVsZUlEc1tidWlsZENvbmZpZ3VyYXRpb24ub3V0cHV0RXh0ZW5zaW9uXSA9IFtdXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vZHVsZUZpbGVQYXRoOnN0cmluZyBvZiBidWlsZENvbmZpZ3VyYXRpb24uZmlsZVBhdGhzKVxuICAgICAgICAgICAgICAgIGlmICghbW9kdWxlRmlsZVBhdGhzVG9FeGNsdWRlLmluY2x1ZGVzKG1vZHVsZUZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZU1vZHVsZUZpbGVQYXRoOnN0cmluZyA9ICcuLycgKyBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgbW9kdWxlRmlsZVBhdGgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdG9yeVBhdGg6c3RyaW5nID0gcGF0aC5kaXJuYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVNb2R1bGVGaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZU5hbWU6c3RyaW5nID0gcGF0aC5iYXNlbmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlTW9kdWxlRmlsZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBgLiR7YnVpbGRDb25maWd1cmF0aW9uLmV4dGVuc2lvbn1gKVxuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kdWxlSUQ6c3RyaW5nID0gYmFzZU5hbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdG9yeVBhdGggIT09ICcuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUlEID0gcGF0aC5qb2luKGRpcmVjdG9yeVBhdGgsIGJhc2VOYW1lKVxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgRW5zdXJlIHRoYXQgZWFjaCBvdXRwdXQgdHlwZSBoYXMgb25seSBvbmUgc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmplY3RlZE1vZHVsZUlEc1tcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbi5vdXRwdXRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhtb2R1bGVJRCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5zdXJlIHRoYXQgc2FtZSBtb2R1bGUgaWRzIGFuZCBkaWZmZXJlbnQgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgYnkgdGhlaXIgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKEphdmFTY3JpcHQtTW9kdWxlcyByZW1haW5zIHdpdGhvdXQgZXh0ZW5zaW9uIHNpbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhleSB3aWxsIGJlIGhhbmRsZWQgZmlyc3QgYmVjYXVzZSB0aGUgYnVpbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9ucyBhcmUgZXhwZWN0ZWQgdG8gYmUgc29ydGVkIGluIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0KS5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmhhc093blByb3BlcnR5KG1vZHVsZUlEKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVsYXRpdmVNb2R1bGVGaWxlUGF0aF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W21vZHVsZUlEXSA9IHJlbGF0aXZlTW9kdWxlRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdGVkTW9kdWxlSURzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29uZmlndXJhdGlvbi5vdXRwdXRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIF0ucHVzaChtb2R1bGVJRClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgYSBjb25jcmV0ZSBmaWxlIHBhdGggZm9yIGdpdmVuIG1vZHVsZSBpZC5cbiAgICAgKiBAcGFyYW0gbW9kdWxlSUQgLSBNb2R1bGUgaWQgdG8gZGV0ZXJtaW5lLlxuICAgICAqIEBwYXJhbSBhbGlhc2VzIC0gTWFwcGluZyBvZiBhbGlhc2VzIHRvIHRha2UgaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBtb2R1bGVSZXBsYWNlbWVudHMgLSBNYXBwaW5nIG9mIHJlcGxhY2VtZW50cyB0byB0YWtlIGludG9cbiAgICAgKiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIC0gTGlzdCBvZiBmaWxlIGFuZCBtb2R1bGUgZXh0ZW5zaW9ucyB0byB0YWtlIGludG9cbiAgICAgKiBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBjb250ZXh0IC0gRmlsZSBwYXRoIHRvIGRldGVybWluZSByZWxhdGl2ZSB0by5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlUGF0aCAtIFBhdGggdG8gcmVzb2x2ZSBsb2NhbCBtb2R1bGVzIHJlbGF0aXZlIHRvLlxuICAgICAqIEBwYXJhbSBwYXRoc1RvSWdub3JlIC0gUGF0aHMgd2hpY2ggbWFya3MgbG9jYXRpb24gdG8gaWdub3JlLlxuICAgICAqIEBwYXJhbSByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocyAtIExpc3Qgb2YgcmVsYXRpdmUgZmlsZSBwYXRoIHRvIHNlYXJjaFxuICAgICAqIGZvciBtb2R1bGVzIGluLlxuICAgICAqIEBwYXJhbSBwYWNrYWdlRW50cnlGaWxlTmFtZXMgLSBMaXN0IG9mIHBhY2thZ2UgZW50cnkgZmlsZSBuYW1lcyB0b1xuICAgICAqIHNlYXJjaCBmb3IuIFRoZSBtYWdpYyBuYW1lIFwiX19wYWNrYWdlX19cIiB3aWxsIHNlYXJjaCBmb3IgYW4gYXBwcmVjaWF0ZVxuICAgICAqIGVudHJ5IGluIGEgXCJwYWNrYWdlLmpzb25cIiBmaWxlLlxuICAgICAqIEBwYXJhbSBwYWNrYWdlTWFpblByb3BlcnR5TmFtZXMgLSBMaXN0IG9mIHBhY2thZ2UgZmlsZSBtYWluIHByb3BlcnR5XG4gICAgICogbmFtZXMgdG8gc2VhcmNoIGZvciBwYWNrYWdlIHJlcHJlc2VudGluZyBlbnRyeSBtb2R1bGUgZGVmaW5pdGlvbnMuXG4gICAgICogQHBhcmFtIHBhY2thZ2VBbGlhc1Byb3BlcnR5TmFtZXMgLSBMaXN0IG9mIHBhY2thZ2UgZmlsZSBhbGlhcyBwcm9wZXJ0eVxuICAgICAqIG5hbWVzIHRvIHNlYXJjaCBmb3IgcGFja2FnZSBzcGVjaWZpYyBtb2R1bGUgYWxpYXNlcy5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgLSBFbmNvZGluZyB0byB1c2UgZm9yIGZpbGUgbmFtZXMgZHVyaW5nIGZpbGUgdHJhdmVyc2luZy5cbiAgICAgKiBAcmV0dXJucyBGaWxlIHBhdGggb3IgZ2l2ZW4gbW9kdWxlIGlkIGlmIGRldGVybWluYXRpb25zIGhhcyBmYWlsZWQgb3JcbiAgICAgKiB3YXNuJ3QgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHN0YXRpYyBkZXRlcm1pbmVNb2R1bGVGaWxlUGF0aChcbiAgICAgICAgbW9kdWxlSUQ6c3RyaW5nLCBhbGlhc2VzOlBsYWluT2JqZWN0ID0ge30sXG4gICAgICAgIG1vZHVsZVJlcGxhY2VtZW50czpQbGFpbk9iamVjdCA9IHt9LCBleHRlbnNpb25zOkV4dGVuc2lvbnMgPSB7XG4gICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWw6IFsnLmpzJ10sXG4gICAgICAgICAgICAgICAgaW50ZXJuYWw6IFtcbiAgICAgICAgICAgICAgICAgICAgJy5qcycsICcuanNvbicsICcuY3NzJywgJy5lb3QnLCAnLmdpZicsICcuaHRtbCcsICcuaWNvJyxcbiAgICAgICAgICAgICAgICAgICAgJy5qcGcnLCAnLnBuZycsICcuZWpzJywgJy5zdmcnLCAnLnR0ZicsICcud29mZicsICcud29mZjInXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSwgbW9kdWxlOiBbXVxuICAgICAgICB9LCBjb250ZXh0OnN0cmluZyA9ICcuLycsIHJlZmVyZW5jZVBhdGg6c3RyaW5nID0gJycsXG4gICAgICAgIHBhdGhzVG9JZ25vcmU6QXJyYXk8c3RyaW5nPiA9IFsnLmdpdCddLFxuICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRoczpBcnJheTxzdHJpbmc+ID0gWydub2RlX21vZHVsZXMnXSxcbiAgICAgICAgcGFja2FnZUVudHJ5RmlsZU5hbWVzOkFycmF5PHN0cmluZz4gPSBbJ2luZGV4J10sXG4gICAgICAgIHBhY2thZ2VNYWluUHJvcGVydHlOYW1lczpBcnJheTxzdHJpbmc+ID0gWydtYWluJ10sXG4gICAgICAgIHBhY2thZ2VBbGlhc1Byb3BlcnR5TmFtZXM6QXJyYXk8c3RyaW5nPiA9IFtdLFxuICAgICAgICBlbmNvZGluZzpzdHJpbmcgPSAndXRmLTgnXG4gICAgKTo/c3RyaW5nIHtcbiAgICAgICAgbW9kdWxlSUQgPSBIZWxwZXIuYXBwbHlNb2R1bGVSZXBsYWNlbWVudHMoSGVscGVyLmFwcGx5QWxpYXNlcyhcbiAgICAgICAgICAgIEhlbHBlci5zdHJpcExvYWRlcihtb2R1bGVJRCksIGFsaWFzZXNcbiAgICAgICAgKSwgbW9kdWxlUmVwbGFjZW1lbnRzKVxuICAgICAgICBpZiAoIW1vZHVsZUlEKVxuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgbGV0IG1vZHVsZUZpbGVQYXRoOnN0cmluZyA9IG1vZHVsZUlEXG4gICAgICAgIGlmIChtb2R1bGVGaWxlUGF0aC5zdGFydHNXaXRoKCcuLycpKVxuICAgICAgICAgICAgbW9kdWxlRmlsZVBhdGggPSBwYXRoLmpvaW4ocmVmZXJlbmNlUGF0aCwgbW9kdWxlRmlsZVBhdGgpXG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlTG9jYXRpb246c3RyaW5nIG9mIFtyZWZlcmVuY2VQYXRoXS5jb25jYXQoXG4gICAgICAgICAgICByZWxhdGl2ZU1vZHVsZUZpbGVQYXRocy5tYXAoKGZpbGVQYXRoOnN0cmluZyk6c3RyaW5nID0+XG4gICAgICAgICAgICAgICAgcGF0aC5yZXNvbHZlKGNvbnRleHQsIGZpbGVQYXRoKSlcbiAgICAgICAgKSlcbiAgICAgICAgICAgIGZvciAobGV0IGZpbGVOYW1lOnN0cmluZyBvZiBbJycsICdfX3BhY2thZ2VfXyddLmNvbmNhdChcbiAgICAgICAgICAgICAgICBwYWNrYWdlRW50cnlGaWxlTmFtZXNcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBtb2R1bGVFeHRlbnNpb246c3RyaW5nIG9mIGV4dGVuc2lvbnMubW9kdWxlLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgXSkpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlsZUV4dGVuc2lvbjpzdHJpbmcgb2YgWycnXS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLmZpbGUuaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRNb2R1bGVGaWxlUGF0aDpzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVGaWxlUGF0aC5zdGFydHNXaXRoKCcvJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vZHVsZUZpbGVQYXRoID0gcGF0aC5yZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVGaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9kdWxlRmlsZVBhdGggPSBwYXRoLnJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUxvY2F0aW9uLCBtb2R1bGVGaWxlUGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYWNrYWdlQWxpYXNlczpQbGFpbk9iamVjdCA9IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUgPT09ICdfX3BhY2thZ2VfXycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVG9vbHMuaXNEaXJlY3RvcnlTeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9kdWxlRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhUb1BhY2thZ2VKU09OOnN0cmluZyA9IHBhdGgucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb2R1bGVGaWxlUGF0aCwgJ3BhY2thZ2UuanNvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChUb29scy5pc0ZpbGVTeW5jKHBhdGhUb1BhY2thZ2VKU09OKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvY2FsQ29uZmlndXJhdGlvbjpQbGFpbk9iamVjdCA9IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ29uZmlndXJhdGlvbiA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVTeXN0ZW0ucmVhZEZpbGVTeW5jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFRvUGFja2FnZUpTT04sIHtlbmNvZGluZ30pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZTpzdHJpbmcgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrYWdlTWFpblByb3BlcnR5TmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICYmIHR5cGVvZiBsb2NhbENvbmZpZ3VyYXRpb25bXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDb25maWd1cmF0aW9uW3Byb3BlcnR5TmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWUgPSBsb2NhbENvbmZpZ3VyYXRpb25bXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWU6c3RyaW5nIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZUFsaWFzUHJvcGVydHlOYW1lc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGxvY2FsQ29uZmlndXJhdGlvbltcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdID09PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrYWdlQWxpYXNlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbENvbmZpZ3VyYXRpb25bXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUgPT09ICdfX3BhY2thZ2VfXycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZSA9IEhlbHBlci5hcHBseU1vZHVsZVJlcGxhY2VtZW50cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBIZWxwZXIuYXBwbHlBbGlhc2VzKGZpbGVOYW1lLCBwYWNrYWdlQWxpYXNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlUmVwbGFjZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRNb2R1bGVGaWxlUGF0aCA9IHBhdGgucmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vZHVsZUZpbGVQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtmaWxlTmFtZX0ke21vZHVsZUV4dGVuc2lvbn0ke2ZpbGVFeHRlbnNpb259YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9kdWxlRmlsZVBhdGggKz1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZmlsZU5hbWV9JHttb2R1bGVFeHRlbnNpb259JHtmaWxlRXh0ZW5zaW9ufWBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChIZWxwZXIuaXNGaWxlUGF0aEluTG9jYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE1vZHVsZUZpbGVQYXRoLCBwYXRoc1RvSWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVG9vbHMuaXNGaWxlU3luYyhjdXJyZW50TW9kdWxlRmlsZVBhdGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50TW9kdWxlRmlsZVBhdGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICAvLyBlbmRyZWdpb25cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGEgY29uY3JldGUgZmlsZSBwYXRoIGZvciBnaXZlbiBtb2R1bGUgaWQuXG4gICAgICogQHBhcmFtIG1vZHVsZUlEIC0gTW9kdWxlIGlkIHRvIGRldGVybWluZS5cbiAgICAgKiBAcGFyYW0gYWxpYXNlcyAtIE1hcHBpbmcgb2YgYWxpYXNlcyB0byB0YWtlIGludG8gYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYWxpYXMgYXBwbGllZCBnaXZlbiBtb2R1bGUgaWQuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5QWxpYXNlcyhtb2R1bGVJRDpzdHJpbmcsIGFsaWFzZXM6UGxhaW5PYmplY3QpOnN0cmluZyB7XG4gICAgICAgIGZvciAoY29uc3QgYWxpYXM6c3RyaW5nIGluIGFsaWFzZXMpXG4gICAgICAgICAgICBpZiAoYWxpYXMuZW5kc1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGVJRCA9PT0gYWxpYXMuc3Vic3RyaW5nKDAsIGFsaWFzLmxlbmd0aCAtIDEpKVxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IGFsaWFzZXNbYWxpYXNdXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IG1vZHVsZUlELnJlcGxhY2UoYWxpYXMsIGFsaWFzZXNbYWxpYXNdKVxuICAgICAgICByZXR1cm4gbW9kdWxlSURcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhIGNvbmNyZXRlIGZpbGUgcGF0aCBmb3IgZ2l2ZW4gbW9kdWxlIGlkLlxuICAgICAqIEBwYXJhbSBtb2R1bGVJRCAtIE1vZHVsZSBpZCB0byBkZXRlcm1pbmUuXG4gICAgICogQHBhcmFtIHJlcGxhY2VtZW50cyAtIE1hcHBpbmcgb2YgcmVndWxhciBleHByZXNzaW9ucyB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgcmVwbGFjZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXBsYWNlbWVudCBhcHBsaWVkIGdpdmVuIG1vZHVsZSBpZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlNb2R1bGVSZXBsYWNlbWVudHMoXG4gICAgICAgIG1vZHVsZUlEOnN0cmluZywgcmVwbGFjZW1lbnRzOlBsYWluT2JqZWN0XG4gICAgKTpzdHJpbmcge1xuICAgICAgICBmb3IgKGNvbnN0IHJlcGxhY2VtZW50OnN0cmluZyBpbiByZXBsYWNlbWVudHMpXG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRzLmhhc093blByb3BlcnR5KHJlcGxhY2VtZW50KSlcbiAgICAgICAgICAgICAgICBtb2R1bGVJRCA9IG1vZHVsZUlELnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAocmVwbGFjZW1lbnQpLCByZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdKVxuICAgICAgICByZXR1cm4gbW9kdWxlSURcbiAgICB9XG59XG4vLyBlbmRyZWdpb25cbi8vIHJlZ2lvbiB2aW0gbW9kbGluZVxuLy8gdmltOiBzZXQgdGFic3RvcD00IHNoaWZ0d2lkdGg9NCBleHBhbmR0YWI6XG4vLyB2aW06IGZvbGRtZXRob2Q9bWFya2VyIGZvbGRtYXJrZXI9cmVnaW9uLGVuZHJlZ2lvbjpcbi8vIGVuZHJlZ2lvblxuIl19